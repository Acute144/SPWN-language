RIGHT = ?b
LEFT = ?b
INCR = ?b
DECR = ?b
DOT = ?b
INPUT = ?b
OPEN = ?b //opening bracket
CLOSE = ?b //closing bracket

END = ?b //end of the program

spacing = 10
extract obj_props
gs = import gamescene


type @bytedisplay 

impl @bytedisplay {
    new: (offset: [@number]) {
        1c.set(255, 255, 255)
        //order = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[ ]^_`abcdefghijklmnopqrstuvwxyz{|}~"
        order = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        list = []
        for ch in order {
            color = ?c
            
            $.add(obj {
                OBJ_ID: 914,
                X: offset[0],
                Y: offset[1],
                TEXT: $.b64encrypt(ch),
                COLOR: color,
            })
            color.set(0,0,0, blending = true)
            list.push(color)
        }
        return @bytedisplay::{list: list, chars: order.length}
    },
    display: (self, index: @number) {
        for i in ..self.list.length {
            if i == index {
                -> self.list[index].pulse(0,255,0, fade_out = 0.5)
                -> self.list[index].set(255,255,255, 0.5)
            } else {
                self.list[i].set(0,0,0, blending = true)
            }
        }
    }
}

type @bfreader
layers = counter(0)
//layers.display(150, 300)

impl @bfreader {
    new: (script_offset: [@number], cell_count: @number) {
        
        extract obj_props
        block = ?b
        group = ?g
        $.add(obj {
            OBJ_ID: 1816,
            X: script_offset[0] - spacing * 6,
            Y: script_offset[1],
            GROUPS: group,
            BLOCK_A: block,
            SCALING: 0.5,
            DYNAMIC_BLOCK: true,
        })
        // for b in [RIGHT,LEFT,INCR,DECR,DOT,OPEN,CLOSE] {
        //     $.add(obj {
        //         OBJ_ID: 1816,
        //         X: script_offset[0] - spacing * 3,
        //         Y: script_offset[1],
        //         SCALING: 0.5,
        //         BLOCK_A: b,
        //     })
        // }

        //start point
        start_point = ?g
        $.add(obj {
            OBJ_ID: 1765,
            X: script_offset[0],
            Y: script_offset[1],
            GROUPS: start_point
        })
        

        // CREATE CELLS
        let cells = []
        for i in ..cell_count {
            c = counter()
            cells.push(c)
            c.display(script_offset[0] + i * 45 + 300, script_offset[1] + 150)
        }
        ptr = counter(0)
        ptr.display(script_offset[0], script_offset[1] + 60)
        std_in = counter(0)
        std_in.display(script_offset[0], script_offset[1] - 90)

        std_out = @bytedisplay::new([script_offset[0], script_offset[1] + 180])
        num_out = counter(0)
        num_out.display(script_offset[0], script_offset[1] + 210)
        out = @bfreader::{
            group: group,
            right: counter(block.create_tracker_item(RIGHT)),
            left:  counter(block.create_tracker_item(LEFT)),
            incr:  counter(block.create_tracker_item(INCR)),
            dot:  counter(block.create_tracker_item(DOT)),
            input:  counter(block.create_tracker_item(INPUT)),
            decr:  counter(block.create_tracker_item(DECR)),
            open:  counter(block.create_tracker_item(OPEN)),
            close: counter(block.create_tracker_item(CLOSE)),
            end: counter(block.create_tracker_item(END)),
            std_out: std_out,
            num_out: num_out,
            std_in: std_in,
            ptr: ptr,
            cells: cells,
            start_point: start_point
        }
        group.move_to(start_point, 0.3)

        return out
    },
    currently_on: (self) {
        if self.right == 1 {
            return RIGHT
        } else if self.left == 1 {
            return LEFT
        } else if self.incr == 1 {
            return INCR
        } else if self.decr == 1 {
            return DECR
        } else if self.dot == 1 {
            return DOT
        } else if self.input == 1 {
            return INPUT
        } else if self.open == 1 {
            return OPEN
        } else if self.close == 1 {
            return CLOSE
        }
    },
    current_cell: (self) => self.cells[self.ptr.to_const(..self.cells.length)],
    interpret: (self) {
        
        ret = !{
            self.group.move(spacing, 0, 0)
            -> return
        }
        current = self.currently_on()
        
        if current == RIGHT {
            self.ptr += 1
            self.ptr.item.if_is(EQUAL_TO, self.cells.length, !{
                self.ptr -= self.cells.length
            })
            ret!
        }
        else if current == LEFT {
            self.ptr -= 1
            self.ptr.item.if_is(EQUAL_TO, -1, !{
                self.ptr += self.cells.length
            })
            ret!
        }
        else if current == INCR {
            -> self.current_cell() += 1
            ret!
        }
        else if current == DECR {
            -> self.current_cell() -= 1
            ret!
        }
        else if current == DOT {
            BG.pulse(0, 255, 0, fade_out = 0.6)
            () {
                self.num_out.reset(3)
                cell = self.current_cell()
                wait()
                cell.copy_to([self.num_out], speed = 1)
            } ()
            wait()
            if self.num_out < self.std_out.chars {
                self.std_out.display(self.num_out.to_const(..self.std_out.chars))
            }
            ret!
        }
        else if current == INPUT {
            
            std_in = self.std_in
            
            func = !{
                gs.button_a().on_triggered(!{
                    std_in += 1
                })
                gs.button_b().on_triggered(!{
                    func.start_group.stop()
                    cell = self.current_cell()
                    wait()
                    cell.reset(speed = 1)
                    std_in.add_to([cell], speed = 1)
                    ret!
                })
            }
            func!
            
        }
        else if current == OPEN {
            move_to = !{
                //move to corresponding ]
                //layers = counter(0)
                condition = ()=> self.currently_on() != CLOSE || layers > 0
                self.group.move(spacing, 0, 0.06)
                while_loop(condition, delay = 0, (){
                    wait(0.01)
                    if self.currently_on() == OPEN {
                        layers += 1
                    } else if self.currently_on() == CLOSE {
                        layers -= 1
                    }
                    self.group.move(spacing, 0)
                    wait()
                })
                ret!
            }
            if self.current_cell() == 0 {
                move_to!
            } else {
                ret!
            }
        }
        else if current == CLOSE {
            move_back = !{
                //move back to corresponding [
                //layers = counter(0)
                condition = ()=> self.currently_on() != OPEN || layers > 0
                self.group.move(-spacing, 0, 0.06)
                while_loop(condition, delay = 0, (){
                    wait(0.01)
                    if self.currently_on() == CLOSE {
                        layers += 1
                    } else if self.currently_on() == OPEN {
                        layers -= 1
                    }
                    self.group.move(-spacing, 0)
                    wait()
                })
                ret!
            }
            if self.current_cell() != 0 {
                move_back!
            } else {
                ret!
            }
        }
        
        
    }
}



insert_bf_cmd = (ch: @string, offset: [@number], group: @group) {
    
    blockid = switch ch {
        case ">": RIGHT,//increment the data pointer (to point to the next cell to the right).
        case "<": LEFT,	//decrement the data pointer (to point to the next cell to the left).
        case "+": INCR,	//increment (increase by one) the byte at the data pointer.
        case "-": DECR,	//decrement (decrease by one) the byte at the data pointer.
        case ".": DOT,	//output the byte at the data pointer.
        case ",": INPUT,//accept one byte of input, storing its value in the byte at the data pointer.
        case "[": OPEN,	
        case "]": CLOSE,
        case "e": END,
        
    }
    
    extract obj_props
    $.add(obj {
        OBJ_ID: 1816,
        X: offset[0],
        Y: offset[1],
        BLOCK_A: blockid,
        GROUPS: group,
        SCALING: 0.2,
    })
    $.add(obj {
        OBJ_ID: 914,
        X: offset[0],
        Y: offset[1],
        TEXT: $.b64encrypt(ch),
        GROUPS: group,
        COLOR: 1c,
    })
}

offset = [300, 300]
sel_off = [300, 900]

commands = 20

selector = {block: ?b, group: ?g, start: ?g}



$.add(obj {
    OBJ_ID: 1765,
    X: sel_off[0] - 60,
    Y: sel_off[1] - 60,
    GROUPS: selector.start,
})

$.add(obj {
    OBJ_ID: 1816,
    X: sel_off[0] - 60,
    Y: sel_off[1] - 60,
    BLOCK_A: selector.block,
    GROUPS: selector.group,
    DYNAMIC_BLOCK: true,
})

gs.button_a().on_triggered(!{
    selector.group.move(20, 0, 0.1)
})

gs.button_b().on_triggered(!{
    selector.group.move(0, 20, 0)
    wait()
    selector.group.move(0, -20, 0)
})

reset_selector = ?b

for i in ..3 {
    $.add(obj {
        OBJ_ID: 1816,
        X: sel_off[0] + commands * 60,
        Y: sel_off[1] - 30 * i,
        BLOCK_A: reset_selector,
        SCALING: 0.5,
    })
}
reset_selector_func = !{
    wait(0.1)
    selector.group.move_to(selector.start)
}

collision(reset_selector, selector.block).on_triggered(reset_selector_func)
y_spacing = 15

for i in ..commands {
    sg = ?g
    c = counter(0)
    c.display(sel_off[0] + i * 60, sel_off[1] + 30)
    order = "+-<>[].,e"
    for c in ..order.length {
        insert_bf_cmd(order[c], [offset[0] + i * spacing * 3, offset[1] + (c + 1) * y_spacing * 3], sg)
    }
    // block that increments the selector
    inc_block = ?b
    $.add(obj {
        OBJ_ID: 1816,
        X: sel_off[0] + i * 60,
        Y: sel_off[1],
        BLOCK_A: inc_block,
        SCALING: 0.5,
    })

    // block that checks for end
    end_check_block = ?b
    $.add(obj {
        OBJ_ID: 1816,
        X: sel_off[0] + i * 60 + 30,
        Y: sel_off[1] - 60,
        BLOCK_A: end_check_block,
        SCALING: 0.5,
    })

    // block that resets the selector
    reset_block = ?b
    $.add(obj {
        OBJ_ID: 1816,
        X: offset[0] + i * spacing * 3,
        Y: offset[1] - order.length * y_spacing * 3,
        BLOCK_A: reset_block,
        DYNAMIC_BLOCK: true,
        SCALING: 0.5,
    })

    collision(end_check_block, selector.block).on_triggered(!{c.item.if_is(EQUAL_TO, order.length, reset_selector_func)})

    collision(inc_block, selector.block).on_triggered(!{
        sg.move(0, -y_spacing, 0.1)
        c += 1
    })

    collision(INCR, reset_block).on_triggered(!{
        sg.move(0, y_spacing * order.length, 0.1)
        c -= order.length
    })
    
}
// end
$.add(obj {
    OBJ_ID: 1816,
    X:  offset[0] + commands * spacing * 3,
    Y:  offset[1],
    BLOCK_A: END,
    SCALING: 0.2,
})

//run button

// block that runs the thing
run_block = ?b
$.add(obj {
    OBJ_ID: 1816,
    X: sel_off[0] - 60,
    Y: sel_off[1],
    BLOCK_A: run_block,
    SCALING: 0.5,
})
reader = @bfreader::new(offset, 16)
collision(run_block, selector.block).on_triggered(!{
    while_loop(()=>reader.end == 0, (){
        reader.interpret()
    })
    for c in reader.cells {
        -> c.reset(speed = 1)
    }
    reader.ptr.reset()
    reader.group.move_to(reader.start_point)
})



