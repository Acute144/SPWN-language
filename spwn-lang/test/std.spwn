
let constants = import "constants.spwn"

extract constants.obj_props
extract constants.comparisons
extract constants.easing_types

wait = #[desc("Adds a delay before the next triggers")] (
    #[desc("Delay time in seconds")] time
){
    
    $.add( obj{
        OBJ_ID: 1268,
        SPAWN_DURATION: time,
        TARGET: {
            return
        },
    })
    
}

call_with_delay = #[desc("Call a function after a delay")] (
    #[desc("Delay time in seconds")] time, 
    #[desc("Function to call after the delay")] function
) {
    $.add(obj{
        OBJ_ID: 1268,
        SPAWN_DURATION: time,
        TARGET: function,
    })
}

impl @group {
    move: #[desc("Implementation of the move trigger")] 
    (
        self, 
        #[desc("Units to move on the X axis")] x, 
        #[desc("Units to move on the Y axis")] y, 
        #[desc("Duration of movement")] duration: 0, 
        easing: NONE, 
        easing_rate: 2
    ) {
        $.add( obj{
            OBJ_ID: 901,
            TARGET: self,
            MOVE_X: x * 3,
            MOVE_Y: y * 3,
            DURATION: duration,
            EASING: easing,
            EASING_RATE: easing_rate,
        })
        
        wait(duration)
    },

    stop: #[desc("Implementation of the stop trigger")]
    (self){
        $.add( obj{
            OBJ_ID: 1616,
            TARGET: self,
        })
    },

    alpha: #[desc("Implementation of the alpha trigger")] 
    (self, opacity: 1, duration: 0){
        $.add( obj {
            OBJ_ID: 1007,
            TARGET: self,
            OPACITY: opacity,
            DURATION: duration,
        })
        wait(duration)
    },

    toggle_on:
    #[desc("Toggles the group on")] 
    (self){
        $.add( obj{
            OBJ_ID: 1049,
            TARGET: self,
            ACTIVATE_GROUP: true,
        })
    },

    toggle_off: #[desc("Toggles the group off")] 
    (self){
        $.add( obj{
            OBJ_ID: 1049,
            TARGET: self,
            ACTIVATE_GROUP: false,
        })
    },

    rotate: #[desc("Implementation of the rotate trigger")] 
    (
        self, 
        #[desc("Group of object to rotate around")] center, 
        #[desc("Rotation in degrees")] degrees, 
        #[desc("Duration of rotation")] duration: 0, 
        #[desc("Easing type")] easing: 0, 
        #[desc("Easing rate")] easing_rate: 0, 
        #[desc("Only rotate positions of the objects, not the textures")] lock_object_rotation: false
    ){
        $.add( obj{
            OBJ_ID: 1346,
            TARGET: self,
            CENTER: center,
            ROTATE_DEGREES: degrees,
            DURATION: duration,
            EASING: easing,
            EASING_RATE: easing_rate,
            LOCK_OBJECT_ROTATION: lock_object_rotation
        })
        wait(duration)
    },

    follow: 
    #[desc("Implementation of the follow trigger")] 
    (
        self, 
        #[desc("Group of object to follow")] other, 
        #[desc("Multiplier for the movement on the X-axis")] x_mod: 1, 
        #[desc("Multiplier for the movement on the Y-axis")] y_mod: 1, 
        #[desc("Duration of following")] duration: 999
    ){
        $.add( obj{
            OBJ_ID: 1347,
            X_MOD: x_mod,
            Y_MOD: y_mod,
            DURATION: duration,
            TARGET: self,
            FOLLOW: other,
        })
        //wouldnt make any sense to wait out the duration here
    },

    follow_player_y:
    #[desc("Implementation of the follow player Y trigger")] 
    (
        self, 
        #[desc("Interpolation factor (?)")] speed: 1, 
        #[desc("Delay of movement")]  delay: 0, 
        #[desc("Offset on the Y-axis")] offset: 0, 
        #[desc("Maximum speed")] max_speed: 0, 
        #[desc("Duration of following")] duration: 999
    ){
        $.add( obj{
            OBJ_ID: 1814,
            SPEED : speed,
            DELAY : delay,
            Y_OFFSET : offset,
            MAX_SPEED : max_speed,
            DURATION: duration,
        })
        //wouldnt make any sense to wait out the duration here
    },

    move_to: 
    #[desc("Implementation of the 'Move target' feature of the move trigger")]
    (
        self, 
        #[desc("Group of the object to move to")] target, 
        #[desc("Duration of movement")] duration: 0,
        #[desc("Will move to the object only on the X-axis")] x_only: false, 
        #[desc("Will move to the object only on the y-axis")] y_only: false, 
        #[desc("Easing type")] easing: NONE, 
        #[desc("Easing rate")] easing_rate: 2
    ) {
        $.add( obj{
            OBJ_ID: 901,
            TARGET: self,
            USE_TARGET: true,

            TARGET_POS_AXES: (){
                if x_only && y_only {
                    return 0
                } else if x_only {
                    return 1
                } else if y_only {
                    return 2
                } else {
                    return 0
                }
            }(),
            TARGET_POS: target,
            
            DURATION: duration,
            EASING: easing,
            EASING_RATE: easing_rate,
        })
        wait(duration)
    },

    pulse: 
    #[desc("Implementation of the pulse trigger for groups")]
    (
        self, 
        #[desc("Red value of pulse color (or hue if HSV is enabled)")] r, 
        #[desc("Green value of pulse color (or saturation if HSV is enabled)")] g, 
        #[desc("Blue value of pulse color (or brightness/value if HSV is enabled)")] b, 
        #[desc("Fade-in duration")] fade_in: 0, 
        #[desc("Duration to hold the color")] hold: 0, 
        #[desc("Fade-out duration")] fade_out: 0, 
        #[desc("Weather to prioritize this pulse over simultaneous pulses")] exclusive: false,
        #[desc("Toggle HSV mode")] hsv: false
    ) {
        $.add( obj{
            OBJ_ID: 1006,
            TRIGGER_RED: r,
            TRIGGER_GREEN: g,
            TRIGGER_BLUE: b,
            EXCLUSIVE: exclusive,
            FADE_IN: fade_in,
            HOLD: hold,
            FADE_OUT: fade_out,
            TARGET_COLOR: self,
            PULSE_MODE: hsv,
            TARGET_TYPE: 1 //group
        })
        wait(fade_in + hold + fade_out)
    }


}



impl @color {
    set: 
    #[desc("Implementation of the color trigger")]
    (
        self, 
        #[desc("Red value of the target color")] r, 
        #[desc("Green value of the target color")] g, 
        #[desc("Blue value of the target color")] b, 
        #[desc("Duration of color change")] duration: 0, 
        #[desc("Opacity of target color")] opacity: 1, 
        #[desc("Toggle blending on target color")] blending: false
    ){
        $.add( obj{
            OBJ_ID: 899,
            DURATION: duration,
            TRIGGER_RED: r,
            TRIGGER_GREEN: g,
            TRIGGER_BLUE: b,
            OPACITY: opacity,
            BLENDING: blending,
            TARGET_COLOR: self,
        })
        wait(duration)
    },

    pulse: #[desc("Implementation of the pulse trigger for colors")]
    (
        self, 
        #[desc("Red value of pulse color (or hue if HSV is enabled)")] r, 
        #[desc("Green value of pulse color (or saturation if HSV is enabled)")] g, 
        #[desc("Blue value of pulse color (or brightness/value if HSV is enabled)")] b, 
        #[desc("Fade-in duration")] fade_in: 0, 
        #[desc("Duration to hold the color")] hold: 0, 
        #[desc("Fade-out duration")] fade_out: 0, 
        #[desc("Weather to prioritize this pulse over simultaneous pulses")] exclusive: false,
        #[desc("Toggle HSV mode")] hsv: false
    ) {
        $.add( obj{
            OBJ_ID: 1006,
            TRIGGER_RED: r,
            TRIGGER_GREEN: g,
            TRIGGER_BLUE: b,
            EXCLUSIVE: exclusive,
            FADE_IN: fade_in,
            HOLD: hold,
            FADE_OUT: fade_out,
            TARGET: self,
            PULSE_MODE: hsv,
            //TARGET_TYPE: 0 //color
        })
        wait(fade_in + hold + fade_out)
    }
}

/*impl @function {

    stop:

    (self) {
        self.group.stop()
    }
}*/



impl @item {
    
    add:
    #[desc("Implementation of the pickup trigger")]
    (self, #[desc("Amount to add")] amount) {
        $.add( obj{
            OBJ_ID: 1817,
            COUNT: amount,
            ITEM: self,
        })
    },

    if_is:
    #[desc("Implementation of the instant count trigger")]
    (
        self, 
        #[desc("Comparison mode")] comparison, 
        #[desc("Number to compare with")] other, 
        #[desc("Target function if comparison is 'true'")] function
    ) {
        $.add( obj{
            OBJ_ID: 1811,
            TARGET: function,
            COUNT: other,
            ACTIVATE_GROUP: 1, 
            COMPARISON: comparison, 
            ITEM: self,
        })
    },

    count:
    #[desc("Implementation of the count trigger (returns an event)")]
    (
        self, 
        #[desc("Number to check against")] number: 0
    ) {
        return (function) {
            $.add( obj{
                OBJ_ID: 1611,
                TARGET: function,
                COUNT: number,
                ACTIVATE_GROUP: 1, 
                ITEM: self,
                COUNT_MULTI_ACTIVATE: true,
                
            })
        }
    },
}

type mut

mut = #[desc("Creates a new mut")] (
    #[desc("Source (can be a number, item ID or boolean)")] source: 0
){
    if source.type == @number {
        id = ?i
    
        id.add(source)
        
        return {
            type: @mut,
            item: id
        }
    } else if source.type == @item {
        return {
            type: @mut,
            item: source
        }
    } else if source.type == @bool {
        id = ?i
    
        if source {
            id.add(1)
        }
        return {
            type: @mut,
            item: id
        }
    } else {
        
        error "Can not make mut from this type"
    }
    
}
    
supress_signal = #[desc("Stops signal from coming past for some time")] (
    #[desc("Time to supress signal")] delay
){
    //if checker is 0, a signal can come through
    //if checker is 1, it will be supressed
    checker = mut(0)
    -> (){
        wait(delay * 2)
        checker.item.if_is(EQUAL_TO, 1, {
            checker.item.add(-1)
        })
    }()
    checker.item.if_is(EQUAL_TO, 0, {
        checker.item.add(1)
        return
    })
    

}


impl @mut {

    add_to: 
    #[desc("Adds the mut's value to all item IDs in a list, and resets the mut to 0 in the process")]
    (
        self, 
        #[desc("Item IDs to add to")] items, 
        #[desc("Speed of operation (higher number increases group usage)")] speed: 1, 
        #[desc("Multiplyer for the value added")] factor: 1
    ) {
        add = {
            
            
            mini_add = (num){
                self.item.if_is(LARGER_THAN, num - 1, {
                    self.item.add(-num)
                    for item in items {
                        item.add(num * factor)
                    }
                    call_with_delay(0.05, add)
                })
            }

            for i in 0..speed {
                mini_add(3^i)
            }
                
                
            
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                supress_signal(0.06)
                return
            })
        }
        add!
    },

    subtract_from:
    #[desc("Subtracts the mut's value from all item IDs in a list, and resets the mut to 0 in the process")]
    (
        self, 
        #[desc("Item IDs to add to")] items, 
        #[desc("Speed of operation (higher number increases group usage)")] speed: 1
    ) {
        sub = {
            
            self.item.if_is(LARGER_THAN, 0, {
                mini_sub = (num){
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        for item in items {
                            item.add(-num)
                        }
                        call_with_delay(0.05, sub)
                    })
                }

                for i in 0..speed {
                    mini_sub(2^i)
                }
                
                
            })
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                supress_signal(0.06)
                return
            })
        }
        sub!
    },

    multiply:
    #[desc("Multiplies the value of the mut by some factor")]
    (
        self,
        #[desc("Factor to multiply by, either another mut (very expensive) or a normal number")] factor,
        #[desc("Speed of operation (higher number increases group usage)")] speed: 1
    ) {
        if factor.type == @number {
            temp = mut(0)
            self.add_to([temp.item], speed, factor)
            temp.add_to([self.item], speed)
        } else if factor.type == @mut {
            
            temp = mut(0)
            mini_mult = (num){
                mult = {
                    
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        factor.copy_to(temp.item, speed, num)
                        
                        
                        call_with_delay(0.1, mult)
                    })
                        
                    self.item.if_is(SMALLER_THAN, num, {
                        wait(0.1)
                        supress_signal(0.11)
                        return
                    })
                }
                mult!
            }
            

            for i in speed..0 {
                mini_mult(2^i)
            }
            
            
            -> factor.reset(speed)
            temp.add_to([self.item], speed * 2)
            
        }
    },


    divide: #[desc("Devides the value of the mut by some divisor")]
    (
        self, 
        #[desc("Divisor to divide by, either another mut (very expensive) or a normal number")] divisor, 
        #[desc("Speed of operation (higher number increases group usage)")] speed: 1, 
        #[desc("Item ID to add the remainder of the division to")] rest_item: ?i
    ) {

        if divisor.type == @number {
            result = mut(0)

            rest = mut(rest_item)

            div = {
                mini_div = (num) {
                    self.item.if_is(LARGER_THAN, (divisor * num) - 1, {
                        
                        
                        self.item.add(-(divisor * num))
                        result.item.add(num)
                        
                        call_with_delay(0.05, div)
                        
                    })
                }

                for i in 0..speed {
                    mini_div(i * 4 + 1)
                }

                self.item.if_is(SMALLER_THAN, divisor, {
                    
                    wait(0.05)
                    self.add_to([rest.item], speed)
                    result.add_to([self.item], speed)
                    supress_signal(0.06)
                    return rest
                })
            }
            div!
        } else if divisor.type == @mut {
            result = mut(0)

            // IDEA:
            // every time it goes under, undo the previous operation to simulate comparison
            
            mini_div = (num){
                div = {
                    
                    
                    self.item.if_is(LARGER_THAN, 0, {
                        //this basically subtracts divisor * num from self
                        (){
                            temp_storage = ?i
                            cas = {
                                mini_cas = (num2){
                                    divisor.item.if_is(LARGER_THAN, num2 - 1, {
                                        divisor.item.add(-num2)
                                        temp_storage.add(num2)
                                        self.item.add(-(num2 * num))


                                        
                                        call_with_delay(0.05, cas)
                                    })
                                }
                    
                                for i in 0..speed {
                                    mini_cas(3^i)
                                }
                                    
                                divisor.item.if_is(EQUAL_TO, 0, {
                                    wait(0.1)
                                    supress_signal(0.11)
                                    mut(temp_storage).add_to([divisor.item], speed*2)
                                    return
                                })
                            }
                            cas!
                        }()
                        result.item.add(num)
                        call_with_delay(0.1, div)
                    })

                    self.item.if_is(SMALLER_THAN, 1, {

                        ret = {
                            supress_signal(0.11)
                            wait(0.1)
                            return
                        }
                        
                        supress_signal(0.06)
                        self.item.if_is(SMALLER_THAN, 0, {
                            result.item.add(-num)
                            wait(0.1)
                            divisor.copy_to(self.item, speed*2, factor = num)
                            ret!
                        })
                        self.item.if_is(EQUAL_TO, 0, ret)
                        
                    })

                    
                }
                div!
            }
            

            
            for i in speed..0 {
                mini_div(8^i)
                wait(0.1)
            }
            -> divisor.reset(speed)
            self.add_to([rest_item], speed*2)
            result.add_to([self.item], speed*2)
            wait(0.2)
            return mut(rest_item)
            
            
         
        }

        
    },

    //will consume both numbers
    /*compare: (self, other, speed: 1) {

        comp = {
            mini_comp = (num){
                self.item.if_is(LARGER_THAN, num, {
                    other.item.if_is(LARGER_THAN, num, {
                        self.item.add(-num)
                        other.item.add(-num)
                        call_with_delay(0.05, comp)
                    })
                })
            }
            for i in 0..speed {
                mini_comp(2^i)
            }
            self.item.if_is(EQUAL_TO, 0, {
                other.item.if_is(LARGER_THAN, 0, {
                    other.reset(speed)
                    return 1
                })
            })

            other.item.if_is(EQUAL_TO, 0, {
                self.item.if_is(LARGER_THAN, 0, {
                    self.reset(speed)
                    return -1
                })
            })

            other.item.if_is(EQUAL_TO, 0, {
                self.item.if_is(EQUAL_TO, 0, {
                    
                    return 0
                    
                })
            })
            
        }
    },*/

    reset: #[desc("Resets mut to 0")]
    (
        self, 
        #[desc("Speed of operation (higher number increases group usage)")] speed: 1
    ){
        //almost the same
        add = {
            self.item.if_is(LARGER_THAN, 0, {
                mini_add = (num){
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        call_with_delay(0.05, add)
                    })
                }

                for i in 0..speed {
                    mini_add(3^i)
                }
                
                
            })
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                return
            })
        }
        add!
    },

    copy_to: #[desc("Copies the value of the mut to another item ID, without consuming the original")] 
    (
        self, 
        #[desc("Item ID to copy to")]  item, 
        #[desc("Speed of operation (higher number increases group usage)")] speed: 1, 
        #[desc("Factor of to multiply the copy by")] factor: 1
    ) {
        temp_storage = ?i
        
        add = {
            
            self.item.if_is(LARGER_THAN, 0, {
                mini_add = (num){
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        
                        item.add(num * factor)
                        temp_storage.add(num)
                        
                        call_with_delay(0.05, add)
                    })
                }

                for i in 0..speed {
                    mini_add(2^i)
                }
                
                
            })
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                supress_signal(0.06)
                mut(temp_storage).add_to([self.item], speed)
                return
            })
        }
        add! 
    },

    clone: #[desc("Copies the mut and returns the copy")] (
        self, 
        #[desc("Speed of operation (higher number increases group usage)")] speed: 1
    ) {
        new_mut = ?i
        self.copy_to(new_mut, speed)
        return mut(new_mut)
    },

    _plus_: (self, other) {
        if other.type == @number {
            new_mut = self.clone()
            new_mut.item.add(other)
        } else if other.type == @mut {
            new_mut = self.clone()
            other.clone().add_to([new_mut.item])
        }
    },

    _minus_: (self, other) {
        if other.type == @number {
            new_mut = self.clone()
            new_mut.item.add(-other)
        }
    },

    _more_than_: (self, other) {
        //TODO: add case for another mut
        if other.type == @number {
            self.item.if_is(LARGER_THAN, other, {
                return true
            })

            self.item.if_is(SMALLER_THAN, other + 1, {
                return false
            })
        }
    },

    _less_than_: (self, other) {
        //TODO: add case for another mut
        if other.type == @number {
            self.item.if_is(SMALLER_THAN, other, {
                return true
            })

            self.item.if_is(LARGER_THAN, other - 1, {
                return false
            })
        }
    },

    _more_or_equal_: (self, other) {
        //TODO: add case for another mut
        if other.type == @number {
            self.item.if_is(LARGER_THAN, other - 1, {
                return true
            })

            self.item.if_is(SMALLER_THAN, other, {
                return false
            })
        }
    },

    _less_or_equal_: (self, other) {
        //TODO: add case for another mut
        if other.type == @number {
            self.item.if_is(SMALLER_THAN, other + 1, {
                return true
            })

            self.item.if_is(LARGER_THAN, other, {
                return false
            })
        }
    },

    _equal_: (self, other) {
        if other.type == @number {
            self.item.if_is(EQUAL_TO, other, {
                return true
            })

            ret_false = {
                return false
            }

            self.item.if_is(LARGER_THAN, other, ret_false)
            self.item.if_is(SMALLER_THAN, other, ret_false)
        }
    },

    _not_equal_: (self, other) {
        if other.type == @number {
            self.item.if_is(EQUAL_TO, other, {
                return false
            })

            ret_true = {
                return true
            }

            self.item.if_is(LARGER_THAN, other, ret_true)
            self.item.if_is(SMALLER_THAN, other, ret_true)
        }
    },

    add: #[desc("Implementation of the pickup trigger")]
    (self, #[desc("Amount to add")] num) {
        self.item.add(num)
    },

    

    to_const: #[desc("Converts the mut into a normal number (very context-splitting, be careful)")] (
        self, 
        #[desc("Array of possible output values")] range
    ) {
        for val in range {
            -> self.item.if_is(EQUAL_TO, val, {
                return val
            }) 
        }
    },
    

    _as_: (self, _type) {
        if _type == @bool {
            return self.to_const([0, 1]) == 1
        } else {
            error "Cannot convert to this type (mut can convert to a number using the mut.to_const macro)"
        }
    }
}





general_functions = {
    
    shake: #[desc("Implementation of the shake trigger")]
    (
        #[desc("Strength value")] strength: 1,
        #[desc("Interval value")] interval: 0,
        #[desc("Duration of shake")] duration: 0.5
    ){
        $.add( obj {
            OBJ_ID: 1520,
            STRENGTH: strength,
            INTERVAL: interval,
            DURATION: duration,
        })
        wait(duration)
    },

    disable_trail: #[desc("Disables the player's trail")] (){
        $.add( obj{
            OBJ_ID: 33,
        })
    },

    enable_trail: #[desc("Enables the player's trail")] (){
        $.add( obj{
            OBJ_ID: 32,
        })
    },

    show_player: #[desc("Shows the player")] (){
        $.add( obj{
            OBJ_ID: 1613,
        })
    },
    
    hide_player: #[desc("Hides the player")] (){
        $.add( obj{
            OBJ_ID: 1612,
        })
    },

    toggle_bg_effect: #[desc("Implementation of the bg effect on/off triggers")] (
        #[desc("Weather to toggle bg effect on or off")] on: false
    ) {
        if on {
            $.add( obj{
                OBJ_ID: 1818,
            })
        } else {
            $.add( obj{
                OBJ_ID: 1819,
            })
        }
    },

    loop: #[desc("Implementation of a spawn loop")] 
    (
        #[desc("Start value for the iterator")] start_val,
        #[desc("End value for the iterator")] end_val, 
        #[desc("Macro of the code that gets looped, should take the iterator (a mut) as the first argument")] code, 
        #[desc("Delay between loops (less than 0.05 may be unstable)")] delay: 0.05, 
        #[desc("Weather to reset the iterator after looping (only disable if the loop is only triggered once)")] reset: true, 
        #[desc("Operation speed of the reset of the iterator, if enabled")] reset_speed: 1
    ) {
        i = mut(start_val)

        func = {
            code(i)
            i.add(1)
            i.item.if_is(SMALLER_THAN, end_val, {
                call_with_delay(delay, func)
            })

            i.item.if_is(LARGER_THAN, end_val - 1, {
                if reset {
                    i.reset(reset_speed)
                }
                return
            })
        }

        func!
        
    }
        
}

// An event in spwn is a macro that returns a macro with one argument
// which is the function that gets triggered on the event

on = #[desc("Triggers a function every time an event fires")] (
    #[desc("Event to trigger on")] event, 
    #[desc("Function to trigger")] function
){
    event(function)
}

events = {
    
    touch: #[desc("Implementation of the touch trigger (returns an event)")] (
        #[desc("Dual mode (only check for touch on the dual side)")] dual_side: false
    ) {
        return (function){
            $.add( obj{
                OBJ_ID: 1595,
                HOLD_MODE: true,
                TOGGLE_MODE: 1,
                TARGET: function,
                DUAL_MODE: dual_side,
                
            })
        }
    },

    touch_end: #[desc("Returns an event for when a touch ends")] (
        #[desc("Dual mode (only check for touch on the dual side)")] dual_side: false
    ) {
        return (function){
            $.add( obj{
                OBJ_ID: 1595,
                HOLD_MODE: true,
                TOGGLE_MODE: 2,
                TARGET: function,
                DUAL_MODE: dual_side,
                
            })
        }
    },

    collision: #[desc("Implementation of the collision trigger (returns an event)")] (
        #[desc("Block A ID")] a, 
        #[desc("Block B ID")] b
    ) {
        return (function){
            $.add( obj{
                OBJ_ID: 1815,
                BLOCK_A: a,
                BLOCK_B: b,
                ACTIVATE_GROUP: true,
                TARGET: function,
                
            })
        }
    },

    collision_exit: #[desc("Returns an event for when a collision exits")] (
        #[desc("Block A ID")] a, 
        #[desc("Block B ID")] b
    ) {
        return (function){
            $.add( obj{
                OBJ_ID: 1815,
                BLOCK_A: a,
                BLOCK_B: b,
                ACTIVATE_GROUP: true,
                ACTIVATE_ON_EXIT: true,
                TARGET: function,
                
            })
        }
    },

    death: #[desc("Returns an event for when the player dies")] (){
        return (function) {
            $.add( obj{
                OBJ_ID: 1812,
                ACTIVATE_GROUP: true,
                TARGET: function
            })
        }
    }
}

impl @block {
    create_tracker_item: #[desc("Returns an item ID that is 1 when the blocks are colliding and 0 when they are not")] 
    (
        self, 
        #[desc("Block ID to check against")] other
    ) {
        item = ?i
        on(events.collision(self, other), {
            item.add(1)
        })

        on(events.collision_exit(self, other), {
            item.add(-1)
        })

        return item
    }
}


exports = {
    obj_props: constants.obj_props,
    ..constants.easing_types,
    ..constants.comparisons,
    ..constants.colors,
    ..general_functions,
    ..events,
    
    wait: wait,
    supress_signal: supress_signal,

    mut: mut,
    call_with_delay: call_with_delay,
    on: on, 
}


