
constants = import "constants.spwn"

* = constants.obj_props
* = constants.comparisons
* = constants.easing_types

wait = (time){
    add obj{
        OBJ_ID: 1268,
        SPAWN_DURATION: time,
        TARGET: {
            return
        }
    }
}

call_with_delay = (time, function) {
    add obj{
        OBJ_ID: 1268,
        SPAWN_DURATION: time,
        TARGET: function
    }
}

impl "group" {
    move: (self, x, y, duration: 0, easing: NONE, easing_rate: 2) {
        add obj{
            OBJ_ID: 901,
            TARGET: self,
            MOVE_X: x * 3,
            MOVE_Y: y * 3,
            DURATION: duration,
            EASING: easing,
            EASING_RATE: easing_rate,
        }
        wait(duration)
    },

    stop: (self){
        add obj{
            OBJ_ID: 1616,
            TARGET: self,
        }
    },

    alpha: (self, opacity: 1, duration: 0){
        add obj {
            OBJ_ID: 1007,
            TARGET: self,
            OPACITY: opacity,
            DURATION: duration,
        }
        wait(duration)
    },

    toggle_on: (self){
        add obj{
            OBJ_ID: 1049,
            TARGET: self,
            ACTIVATE_GROUP: true,
        }
    },

    toggle_off: (self){
        add obj{
            OBJ_ID: 1049,
            TARGET: self,
            ACTIVATE_GROUP: false,
        }
    },

    rotate: (self, center, degrees, duration: 0, easing: 0, easing_rate: 0, lock_object_rotation: 0){
        add obj{
            OBJ_ID: 1346,
            TARGET: self,
            CENTER: center,
            ROTATE_DEGREES: degrees,
            DURATION: duration,
            EASING: easing,
            EASING_RATE: easing_rate,
            LOCK_OBJECT_ROTATION: lock_object_rotation
        }
        wait(duration)
    },

    follow: (self, other, x_mod: 0, y_mod: 0, duration: 999){
        add obj{
            OBJ_ID: 1347,
            X_MOD: x_mod,
            Y_MOD: y_mod,
            DURATION: duration,
            TARGET: self,
            FOLLOW: other,
        }
        //wouldnt make any sense to wait out the duration here
    },

    follow_player_y: (self, speed: 1, delay: 0, offset: 0, max_speed: 0, duration: 999){
        add obj{
            OBJ_ID: 1814,
            SPEED : speed,
            DELAY : delay,
            Y_OFFSET : offset,
            MAX_SPEED : max_speed,
            DURATION: duration,
        }
        //wouldnt make any sense to wait out the duration here
    },

    move_to: (self, target, duration: 0, x_only: false, y_only: false, easing: NONE, easing_rate: 2) {
        add obj{
            OBJ_ID: 901,
            TARGET: self,
            USE_TARGET: true,

            TARGET_POS_AXES: (){
                if x_only && y_only {
                    return 0
                } else if x_only {
                    return 1
                } else if y_only {
                    return 2
                } else {
                    return 0
                }
            }(),
            TARGET_POS: target,
            
            DURATION: duration,
            EASING: easing,
            EASING_RATE: easing_rate,
        }
        wait(duration)
    },

    pulse: (self, r, g, b, fade_in: 0, hold: 0, fade_out: 0, exclusive: false, hsv: false) { //add an option for hsv?
        add obj{
            OBJ_ID: 1006,
            TRIGGER_RED: r,
            TRIGGER_GREEN: g,
            TRIGGER_BLUE: b,
            EXCLUSIVE: exclusive,
            FADE_IN: fade_in,
            HOLD: hold,
            FADE_OUT: fade_out,
            TARGET_COLOR: self,
            PULSE_MODE: hsv,
            TARGET_TYPE: 1 //group
        }
        wait(fade_in + hold + fade_out)
    }


}



impl "color" {
    set: (self, r, g, b, duration: 0, opacity: 1, blending: false){
        add obj{
            OBJ_ID: 899,
            DURATION: duration,
            TRIGGER_RED: r,
            TRIGGER_GREEN: g,
            TRIGGER_BLUE: b,
            OPACITY: opacity,
            BLENDING: blending,
            TARGET_COLOR: self,
        }
        wait(duration)
    },

    pulse: (self, r, g, b, fade_in: 0, hold: 0, fade_out: 0, exclusive: false, hsv: false) { //add an option for hsv?
        add obj{
            OBJ_ID: 1006,
            TRIGGER_RED: r,
            TRIGGER_GREEN: g,
            TRIGGER_BLUE: b,
            EXCLUSIVE: exclusive,
            FADE_IN: fade_in,
            HOLD: hold,
            FADE_OUT: fade_out,
            TARGET_COLOR: self,
            PULSE_MODE: hsv,
            TARGET_TYPE: 0 //color
        }
        wait(fade_in + hold + fade_out)
    }
}

impl "item" {
    
    add: (self, amount) {
        add obj{
            OBJ_ID: 1817,
            COUNT: amount,
            ITEM: self,
        }
    },

    if_is: (self, comparison, other, function) {
        add obj{
            OBJ_ID: 1811,
            TARGET: function,
            COUNT: other,
            ACTIVATE_GROUP: 1, 
            COMPARISON: comparison, 
            ITEM: self,
        }
    },

    count: (self, number: 0) {
        return (function) {
            add obj{
                OBJ_ID: 1611,
                TARGET: function,
                COUNT: number,
                ACTIVATE_GROUP: 1, 
                ITEM: self,
                COUNT_MULTI_ACTIVATE: true
            }
        }
    },
}

mut = (source){
    if source.TYPE == "number" {
        id = ?i
    
        id.add(source)
        
        return {
            TYPE: "mutable",
            item: id
        }
    } else if source.TYPE == "item" {
        return {
            TYPE: "mutable",
            item: source
        }
    } else {
        error "Can not make mut from this type"
    }
    
}
    
supress_signal = (delay){
    //if checker is 0, a signal can come through
    //if checker is 1, it will be supressed
    checker = mut(0)
    -> (){
        wait(delay)
        checker.item.if_is(EQUAL_TO, 1, {
            checker.item.add(-1)
        })
    }()
    checker.item.if_is(EQUAL_TO, 0, {
        checker.item.add(1)
        return
    })
    

}


impl "mutable" {

    add_to: (self, items, speed: 1) {
        add = {
            
            self.item.if_is(LARGER_THAN, 0, {
                mini_add = (num){
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        for item in items {
                            item.add(num)
                        }
                        call_with_delay(0.05, add)
                    })
                }

                for i in 0->speed {
                    mini_add(2^i)
                }
                
                
            })
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                supress_signal(0.06)
                return
            })
        }
        add!
    },

    multiply: (self, factor, speed: 1) {
        factor.item.if_is(EQUAL_TO, 0, {
            self.reset(speed)
            return
        })

        factor.item.if_is(LARGER_THAN, 1, {

            reg = self.clone(speed)
            

            factor.item.add(-1)
            wait(0.05)
            mult = {
                
                factor.item.if_is(LARGER_THAN, 0, {
                    reg.copy_to(self.item, speed)
                    factor.item.add(-1)
                    call_with_delay(0.05, mult)
                })
                factor.item.if_is(EQUAL_TO, 0, {
                    wait(0.05)
                    return
                })
            }
            mult!
        })

        
        
    },

    reset: (self, speed: 1){
        //almost the same
        add = {
            self.item.if_is(LARGER_THAN, 0, {
                mini_add = (num){
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        call_with_delay(0.05, add)
                    })
                }

                for i in 0->speed {
                    mini_add(3^i)
                }
                
                
            })
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                return
            })
        }
        add!
    },

    copy_to: (self, item, speed: 1) {
        temp_storage = ?i
        self.add_to([item, temp_storage], speed)
        mut(temp_storage).add_to([self.item], speed)
        return
    },

    clone: (self, speed: 1) {
        new_mut = ?i
        self.copy_to(new_mut, speed)
        return mut(new_mut)
    },

    _plus_: (self, other) {
        if other.TYPE == "number" {
            new_mut = self.clone()
            new_mut.item.add(other)
        } else if other.TYPE == "mut" {
            new_mut = self.clone()
            other.clone().add_to([new_mut.item])
        }
    },

    _minus_: (self, other) {
        if other.TYPE == "number" {
            new_mut = self.clone()
            new_mut.item.add(-other)
        }
    },
    

    to_const: (self, range) {
        for val in range {
            -> self.item.if_is(EQUAL_TO, val, {
                return val
            }) 
        }
    },
    

    as: (self, type) {
        if type == "bool" {
            return self.to_const([0, 1]) == 1
        } else {
            error "Cannot convert to this type (mut can convert to a number using the mut.to_const macro)"
        }
    }
}





general_functions = {
    
    shake: (strength: 1, interval: 0, duration: 0.5){
        add obj {
            OBJ_ID: 1520,
            STRENGTH: strength,
            INTERVAL: interval,
            DURATION: duration,
        }
        wait(duration)
    },

    disable_trail: (){
        add obj{
            OBJ_ID: 33,
        }
    },

    enable_trail: (){
        add obj{
            OBJ_ID: 32,
        }
    },

    show_player: (){
        add obj{
            OBJ_ID: 1613,
        }
    },
    
    hide_player: (){
        add obj{
            OBJ_ID: 1612,
        }
    },

    toggle_bg_effect: (on: false) {
        if on {
            add obj{
                OBJ_ID: 1818,
            }
        } else {
            add obj{
                OBJ_ID: 1819,
            }
        }
    }
        
}

// An event in spwn is a macro that returns a macro with one argument
// which is the function that gets triggered on the event

on = (event, function){
    event(function)
}

events = {
    touch: (dual_side: false) {
        return (function){
            add obj{
                OBJ_ID: 1595,
                HOLD_MODE: true,
                TOGGLE_MODE: 1,
                TARGET: function,
                DUAL_MODE: dual_side,
                
            }
        }
    },

    touch_end: (dual_side: false) {
        return (function){
            add obj{
                OBJ_ID: 1595,
                HOLD_MODE: true,
                TOGGLE_MODE: 2,
                TARGET: function,
                DUAL_MODE: dual_side,
                
            }
        }
    },

    collision: (a, b) {
        return (function){
            add obj{
                OBJ_ID: 1815,
                BLOCK_A: a,
                BLOCK_B: b,
                ACTIVATE_GROUP: true,
                TARGET: function,
                
            }
        }
    },

    collision_exit: (a, b) {
        return (function){
            add obj{
                OBJ_ID: 1815,
                BLOCK_A: a,
                BLOCK_B: b,
                ACTIVATE_GROUP: true,
                ACTIVATE_ON_EXIT: true,
                TARGET: function,
                
            }
        }
    },

    death: (){
        return (function) {
            add obj{
                OBJ_ID: 1812,
                ACTIVATE_GROUP: true,
                TARGET: function
            }
        }
    }
}



exports = {
    //..constants.obj_props,
    ..constants.easing_types,
    ..constants.comparisons,
    ..general_functions,
    ..events,
    
    wait: wait,


    mut: mut,
    call_with_delay: call_with_delay,
    on: on,

    

    
    
}


