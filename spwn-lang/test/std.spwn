
constants = import "constants.spwn"

extract constants.obj_props
extract constants.comparisons
extract constants.easing_types

wait = (time){
    $.add( obj{
        OBJ_ID: 1268,
        SPAWN_DURATION: time,
        TARGET: {
            return
        },
    })
}

call_with_delay = (time, function) {
    $.add(obj{
        OBJ_ID: 1268,
        SPAWN_DURATION: time,
        TARGET: function,
    })
}

impl "group" {
    move: (self, x, y, duration: 0, easing: NONE, easing_rate: 2) {
        $.add( obj{
            OBJ_ID: 901,
            TARGET: self,
            MOVE_X: x * 3,
            MOVE_Y: y * 3,
            DURATION: duration,
            EASING: easing,
            EASING_RATE: easing_rate,
        })
        wait(duration)
    },

    stop: (self){
        $.add( obj{
            OBJ_ID: 1616,
            TARGET: self,
        })
    },

    alpha: (self, opacity: 1, duration: 0){
        $.add( obj {
            OBJ_ID: 1007,
            TARGET: self,
            OPACITY: opacity,
            DURATION: duration,
        })
        wait(duration)
    },

    toggle_on: (self){
        $.add( obj{
            OBJ_ID: 1049,
            TARGET: self,
            ACTIVATE_GROUP: true,
        })
    },

    toggle_off: (self){
        $.add( obj{
            OBJ_ID: 1049,
            TARGET: self,
            ACTIVATE_GROUP: false,
        })
    },

    rotate: (self, center, degrees, duration: 0, easing: 0, easing_rate: 0, lock_object_rotation: 0){
        $.add( obj{
            OBJ_ID: 1346,
            TARGET: self,
            CENTER: center,
            ROTATE_DEGREES: degrees,
            DURATION: duration,
            EASING: easing,
            EASING_RATE: easing_rate,
            LOCK_OBJECT_ROTATION: lock_object_rotation
        })
        wait(duration)
    },

    follow: (self, other, x_mod: 1, y_mod: 1, duration: 999){
        $.add( obj{
            OBJ_ID: 1347,
            X_MOD: x_mod,
            Y_MOD: y_mod,
            DURATION: duration,
            TARGET: self,
            FOLLOW: other,
        })
        //wouldnt make any sense to wait out the duration here
    },

    follow_player_y: (self, speed: 1, delay: 0, offset: 0, max_speed: 0, duration: 999){
        $.add( obj{
            OBJ_ID: 1814,
            SPEED : speed,
            DELAY : delay,
            Y_OFFSET : offset,
            MAX_SPEED : max_speed,
            DURATION: duration,
        })
        //wouldnt make any sense to wait out the duration here
    },

    move_to: (self, target, duration: 0, x_only: false, y_only: false, easing: NONE, easing_rate: 2) {
        $.add( obj{
            OBJ_ID: 901,
            TARGET: self,
            USE_TARGET: true,

            TARGET_POS_AXES: (){
                if x_only && y_only {
                    return 0
                } else if x_only {
                    return 1
                } else if y_only {
                    return 2
                } else {
                    return 0
                }
            }(),
            TARGET_POS: target,
            
            DURATION: duration,
            EASING: easing,
            EASING_RATE: easing_rate,
        })
        wait(duration)
    },

    pulse: (self, r, g, b, fade_in: 0, hold: 0, fade_out: 0, exclusive: false, hsv: false) { //add an option for hsv?
        $.add( obj{
            OBJ_ID: 1006,
            TRIGGER_RED: r,
            TRIGGER_GREEN: g,
            TRIGGER_BLUE: b,
            EXCLUSIVE: exclusive,
            FADE_IN: fade_in,
            HOLD: hold,
            FADE_OUT: fade_out,
            TARGET_COLOR: self,
            PULSE_MODE: hsv,
            TARGET_TYPE: 1 //group
        })
        wait(fade_in + hold + fade_out)
    }


}



impl "color" {
    set: (self, r, g, b, duration: 0, opacity: 1, blending: false){
        $.add( obj{
            OBJ_ID: 899,
            DURATION: duration,
            TRIGGER_RED: r,
            TRIGGER_GREEN: g,
            TRIGGER_BLUE: b,
            OPACITY: opacity,
            BLENDING: blending,
            TARGET_COLOR: self,
        })
        wait(duration)
    },

    pulse: (self, r, g, b, fade_in: 0, hold: 0, fade_out: 0, exclusive: false, hsv: false) { //add an option for hsv?
        $.add( obj{
            OBJ_ID: 1006,
            TRIGGER_RED: r,
            TRIGGER_GREEN: g,
            TRIGGER_BLUE: b,
            EXCLUSIVE: exclusive,
            FADE_IN: fade_in,
            HOLD: hold,
            FADE_OUT: fade_out,
            TARGET_COLOR: self,
            PULSE_MODE: hsv,
            TARGET_TYPE: 0 //color
        })
        wait(fade_in + hold + fade_out)
    }
}

impl "function" {

    stop: (self) {
        self.group.stop()
    }
}

impl "item" {
    
    add: (self, amount) {
        $.add( obj{
            OBJ_ID: 1817,
            COUNT: amount,
            ITEM: self,
        })
    },

    if_is: (self, comparison, other, function) {
        $.add( obj{
            OBJ_ID: 1811,
            TARGET: function,
            COUNT: other,
            ACTIVATE_GROUP: 1, 
            COMPARISON: comparison, 
            ITEM: self,
        })
    },

    count: (self, number: 0) {
        return (function) {
            $.add( obj{
                OBJ_ID: 1611,
                TARGET: function,
                COUNT: number,
                ACTIVATE_GROUP: 1, 
                ITEM: self,
                COUNT_MULTI_ACTIVATE: true,
                
            })
        }
    },
}

mut = (source: ?i){
    if source.TYPE == "number" {
        id = ?i
    
        id.add(source)
        
        return {
            TYPE: "mutable",
            item: id
        }
    } else if source.TYPE == "item" {
        return {
            TYPE: "mutable",
            item: source
        }
    } else {
        error "Can not make mut from this type"
    }
    
}
    
supress_signal = (delay){
    //if checker is 0, a signal can come through
    //if checker is 1, it will be supressed
    checker = mut(0)
    -> (){
        wait(delay * 2)
        checker.item.if_is(EQUAL_TO, 1, {
            checker.item.add(-1)
        })
    }()
    checker.item.if_is(EQUAL_TO, 0, {
        checker.item.add(1)
        return
    })
    

}


impl "mutable" {

    add_to: (self, items, speed: 1, factor: 1) {
        add = {
            
            
            mini_add = (num){
                self.item.if_is(LARGER_THAN, num - 1, {
                    self.item.add(-num)
                    for item in items {
                        item.add(num * factor)
                    }
                    call_with_delay(0.05, add)
                })
            }

            for i in 0..speed {
                mini_add(3^i)
            }
                
                
            
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                supress_signal(0.06)
                return
            })
        }
        add!
    },

    subtract_from: (self, items, speed: 1) {
        sub = {
            
            self.item.if_is(LARGER_THAN, 0, {
                mini_sub = (num){
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        for item in items {
                            item.add(-num)
                        }
                        call_with_delay(0.05, sub)
                    })
                }

                for i in 0..speed {
                    mini_sub(2^i)
                }
                
                
            })
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                supress_signal(0.06)
                return
            })
        }
        sub!
    },

    multiply: (self, factor, speed: 1) {
        if factor.TYPE == "number" {
            temp = mut(0)
            self.add_to([temp.item], speed, factor)
            temp.add_to([self.item], speed)
        } else if factor.TYPE == "mutable" {
            
            temp = mut(0)
            mini_mult = (num){
                mult = {
                    
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        factor.copy_to(temp.item, speed, num)
                        
                        
                        call_with_delay(0.1, mult)
                    })
                        
                    self.item.if_is(SMALLER_THAN, num, {
                        wait(0.1)
                        supress_signal(0.11)
                        return
                    })
                }
                mult!
            }
            

            for i in speed..0 {
                mini_mult(2^i)
            }
            
            
            -> factor.reset(speed)
            temp.add_to([self.item], speed * 2)
            
        }
    },


    divide: (self, divisor, speed: 1, rest_item: ?i) {

        if divisor.TYPE == "number"{
            result = mut(0)

            rest = mut(rest_item)

            div = {
                mini_div = (num) {
                    self.item.if_is(LARGER_THAN, (divisor * num) - 1, {
                        
                        
                        self.item.add(-(divisor * num))
                        result.item.add(num)
                        
                        call_with_delay(0.05, div)
                        
                    })
                }

                for i in 0..speed {
                    mini_div(i * 4 + 1)
                }

                self.item.if_is(SMALLER_THAN, divisor, {
                    
                    wait(0.05)
                    self.add_to([rest.item], speed)
                    result.add_to([self.item], speed)
                    supress_signal(0.06)
                    return rest
                })
            }
            div!
        } else if divisor.TYPE == "mutable" {
            result = mut(0)

            // IDEA:
            // every time it goes under, undo the previous operation to simulate comparison
            
            mini_div = (num){
                div = {
                    
                    
                    self.item.if_is(LARGER_THAN, 0, {
                        //this basically subtracts divisor * num from self
                        (){
                            temp_storage = ?i
                            cas = {
                                mini_cas = (num2){
                                    divisor.item.if_is(LARGER_THAN, num2 - 1, {
                                        divisor.item.add(-num2)
                                        temp_storage.add(num2)
                                        self.item.add(-(num2 * num))


                                        
                                        call_with_delay(0.05, cas)
                                    })
                                }
                    
                                for i in 0..speed {
                                    mini_cas(3^i)
                                }
                                    
                                divisor.item.if_is(EQUAL_TO, 0, {
                                    wait(0.1)
                                    supress_signal(0.11)
                                    mut(temp_storage).add_to([divisor.item], speed*2)
                                    return
                                })
                            }
                            cas!
                        }()
                        result.item.add(num)
                        call_with_delay(0.1, div)
                    })

                    self.item.if_is(SMALLER_THAN, 1, {

                        ret = {
                            supress_signal(0.11)
                            wait(0.1)
                            return
                        }
                        
                        supress_signal(0.06)
                        self.item.if_is(SMALLER_THAN, 0, {
                            result.item.add(-num)
                            wait(0.1)
                            divisor.copy_to(self.item, speed*2, factor = num)
                            ret!
                        })
                        self.item.if_is(EQUAL_TO, 0, ret)
                        
                    })

                    
                }
                div!
            }
            

            
            for i in speed..0 {
                mini_div(8^i)
                wait(0.1)
            }
            -> divisor.reset(speed)
            self.add_to([rest_item], speed*2)
            result.add_to([self.item], speed*2)
            wait(0.2)
            return mut(rest_item)
            
            
         
        }

        
    },

    //will consume both numbers
    compare: (self, other, speed: 1) {

        comp = {
            mini_comp = (num){
                self.item.if_is(LARGER_THAN, num, {
                    other.item.if_is(LARGER_THAN, num, {
                        self.item.add(-num)
                        other.item.add(-num)
                        call_with_delay(0.05, comp)
                    })
                })
            }
            for i in 0..speed {
                mini_comp(2^i)
            }
            self.item.if_is(EQUAL_TO, 0, {
                other.item.if_is(LARGER_THAN, 0, {
                    other.reset(speed)
                    return 1
                })
            })

            other.item.if_is(EQUAL_TO, 0, {
                self.item.if_is(LARGER_THAN, 0, {
                    self.reset(speed)
                    return -1
                })
            })

            other.item.if_is(EQUAL_TO, 0, {
                self.item.if_is(EQUAL_TO, 0, {
                    
                    return 0
                    
                })
            })
            
        }
    },

    reset: (self, speed: 1){
        //almost the same
        add = {
            self.item.if_is(LARGER_THAN, 0, {
                mini_add = (num){
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        call_with_delay(0.05, add)
                    })
                }

                for i in 0..speed {
                    mini_add(3^i)
                }
                
                
            })
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                return
            })
        }
        add!
    },

    copy_to: (self, item, speed: 1, factor: 1) {
        temp_storage = ?i
        
        add = {
            
            self.item.if_is(LARGER_THAN, 0, {
                mini_add = (num){
                    self.item.if_is(LARGER_THAN, num - 1, {
                        self.item.add(-num)
                        
                        item.add(num * factor)
                        temp_storage.add(num)
                        
                        call_with_delay(0.05, add)
                    })
                }

                for i in 0..speed {
                    mini_add(2^i)
                }
                
                
            })
            self.item.if_is(EQUAL_TO, 0, {
                wait(0.05)
                supress_signal(0.06)
                mut(temp_storage).add_to([self.item], speed)
                return
            })
        }
        add! 
    },

    clone: (self, speed: 1) {
        new_mut = ?i
        self.copy_to(new_mut, speed)
        return mut(new_mut)
    },

    _plus_: (self, other) {
        if other.TYPE == "number" {
            new_mut = self.clone()
            new_mut.item.add(other)
        } else if other.TYPE == "mut" {
            new_mut = self.clone()
            other.clone().add_to([new_mut.item])
        }
    },

    _minus_: (self, other) {
        if other.TYPE == "number" {
            new_mut = self.clone()
            new_mut.item.add(-other)
        }
    },

    _more_than_: (self, other) {
        //TODO: add case for another mut
        if other.TYPE == "number" {
            self.item.if_is(LARGER_THAN, other, {
                return true
            })

            self.item.if_is(SMALLER_THAN, other + 1, {
                return false
            })
        }
    },

    _less_than_: (self, other) {
        //TODO: add case for another mut
        if other.TYPE == "number" {
            self.item.if_is(SMALLER_THAN, other, {
                return true
            })

            self.item.if_is(LARGER_THAN, other - 1, {
                return false
            })
        }
    },

    _more_or_equal_: (self, other) {
        //TODO: add case for another mut
        if other.TYPE == "number" {
            self.item.if_is(LARGER_THAN, other - 1, {
                return true
            })

            self.item.if_is(SMALLER_THAN, other, {
                return false
            })
        }
    },

    _less_or_equal_: (self, other) {
        //TODO: add case for another mut
        if other.TYPE == "number" {
            self.item.if_is(SMALLER_THAN, other + 1, {
                return true
            })

            self.item.if_is(LARGER_THAN, other, {
                return false
            })
        }
    },

    add: (self, num) {
        self.item.add(num)
    },

    

    to_const: (self, range) {
        for val in range {
            -> self.item.if_is(EQUAL_TO, val, {
                return val
            }) 
        }
    },
    

    _as_: (self, type) {
        if type == "bool" {
            return self.to_const([0, 1]) == 1
        } else {
            error "Cannot convert to this type (mut can convert to a number using the mut.to_const macro)"
        }
    }
}





general_functions = {
    
    shake: (strength: 1, interval: 0, duration: 0.5){
        $.add( obj {
            OBJ_ID: 1520,
            STRENGTH: strength,
            INTERVAL: interval,
            DURATION: duration,
        })
        wait(duration)
    },

    disable_trail: (){
        $.add( obj{
            OBJ_ID: 33,
        })
    },

    enable_trail: (){
        $.add( obj{
            OBJ_ID: 32,
        })
    },

    show_player: (){
        $.add( obj{
            OBJ_ID: 1613,
        })
    },
    
    hide_player: (){
        $.add( obj{
            OBJ_ID: 1612,
        })
    },

    toggle_bg_effect: (on: false) {
        if on {
            $.add( obj{
                OBJ_ID: 1818,
            })
        } else {
            $.add( obj{
                OBJ_ID: 1819,
            })
        }
    }
        
}

// An event in spwn is a macro that returns a macro with one argument
// which is the function that gets triggered on the event

on = (event, function){
    event(function)
}

events = {
    touch: (dual_side: false) {
        return (function){
            $.add( obj{
                OBJ_ID: 1595,
                HOLD_MODE: true,
                TOGGLE_MODE: 1,
                TARGET: function,
                DUAL_MODE: dual_side,
                
            })
        }
    },

    touch_end: (dual_side: false) {
        return (function){
            $.add( obj{
                OBJ_ID: 1595,
                HOLD_MODE: true,
                TOGGLE_MODE: 2,
                TARGET: function,
                DUAL_MODE: dual_side,
                
            })
        }
    },

    collision: (a, b) {
        return (function){
            $.add( obj{
                OBJ_ID: 1815,
                BLOCK_A: a,
                BLOCK_B: b,
                ACTIVATE_GROUP: true,
                TARGET: function,
                
            })
        }
    },

    collision_exit: (a, b) {
        return (function){
            $.add( obj{
                OBJ_ID: 1815,
                BLOCK_A: a,
                BLOCK_B: b,
                ACTIVATE_GROUP: true,
                ACTIVATE_ON_EXIT: true,
                TARGET: function,
                
            })
        }
    },

    death: (){
        return (function) {
            $.add( obj{
                OBJ_ID: 1812,
                ACTIVATE_GROUP: true,
                TARGET: function
            })
        }
    }
}



exports = {
    obj_props: constants.obj_props,
    ..constants.easing_types,
    ..constants.comparisons,
    ..general_functions,
    ..events,
    
    wait: wait,
    supress_signal: supress_signal,

    mut: mut,
    call_with_delay: call_with_delay,
    on: on, 
}


