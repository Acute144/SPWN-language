BFEnum = {
	PLUS: 0,
	MINUS: 1,
	GTHAN: 2,
	LTHAN: 3,
	RBRAC: 4,
	LBRAC: 5,
	DOT: 6
};

constants = {
	pointer: 5g,
	pointer_color: 5c,
	highlighted: [0,255,255]
}

pop = (arr: @array) {
	let arr2 = [];
	for ind in 0..arr.length-1 {
		arr2.push(arr[ind])
	}
	return arr2;
}
last = (arr: @array) {
	return arr[arr.length-1]
}

MDFind = (search, arr: @array) {
    broke = counter(0)
	for item in arr {
		if search == item[0]{
            return item[1];
            broke += 1
            break
		}
    }
    if broke == 0 {
        return 0;
    } else {
		broke -= 1
	}
}

stringToArr = (code: @string) {
	let arr = [];
	for chi in 0..code.length {
		char = code[chi];
		if char == '+' {arr.push(BFEnum.PLUS)};
		if char == '-' {arr.push(BFEnum.MINUS)};
		if char == '>' {arr.push(BFEnum.GTHAN)};
		if char == '<' {arr.push(BFEnum.LTHAN)};
		if char == '[' {arr.push(BFEnum.LBRAC)};
		if char == ']' {arr.push(BFEnum.RBRAC)};
		if char == '.' {arr.push(BFEnum.DOT)};
	}
	return arr;
}

type @Cell;
type @BFSystem;

impl @Cell {
	new: (color: @color,item: @item, group: @group) {
		item.add(0);
		return {type: @Cell,item: counter(item), group: group, color: color}
	},
	increment: (self, by) {
		self.item += by;
		->self.color.pulse(0, 255, 0, 0, 0.1, 0.5);
	},
	decrement: (self, by) {
		self.item -= by;
		->self.color.pulse(255, 0, 0, 0, 0.1, 0.5);
	},
	movePointerTo: (self) {
		constants.pointer.move_to(self.group, 0, true);
	}
}

impl @BFSystem {
	new: (num) {
		let slf = {type: @BFSystem};

		let slf.cells = [];
		let slf.cellptr = counter(0);
		let slf.codeptr = counter(69i);
		let slf.codelen = counter(num);
		let slf.code = [];
		for cell in 1..num+1 {
        	slf.cells.push(@Cell::new(cell as @color, cell as @item, cell as @group));
    	}
    	return slf;
	},
	update: (self, updated: @array) {
		for i in updated {
			self.code.push(i);
		}
	},

	shiftPointerR: (self) {
        if self.cellptr == self.cells.length - 1 {
            wait()
            self.cellptr -= self.cells.length - 1
        } else {
            wait()
            self.cellptr+=1;
		}
		wait()
		
    	-> self.cells[self.cellptr.to_const(0..self.cells.length)].movePointerTo();
    },

    shiftPointerL: (self) {
        
        if self.cellptr == 0 {
            wait()
            self.cellptr += self.cells.length - 1
        } else {
            wait()
            self.cellptr-=1;
		}
		wait()
        
        -> self.cells[self.cellptr.to_const(0..self.cells.length)].movePointerTo();
	},
	
	getBracemap: (self) {
		let bracestack = [];
		let bracemap = [];

		let command = 0;
		for position in 0..self.code.length {
			command = self.code[position];

			if command == BFEnum.LBRAC {
				bracestack.push(position);
			} else if command == BFEnum.RBRAC {
				let start = bracestack.pop();

				bracemap.push([start,position]);
				bracemap.push([position,start]);
			}
		}
		return bracemap;
	},

	compile: (self) {
		let bracemap = self.getBracemap();
		$.print(self.code);
		command = counter(70i)
		reset_command = {
			command -= command.to_const(0..7)
		}

		compile_command = sync_function(() {
			
			
			if command == BFEnum.GTHAN {
				wait(0.1)
				self.shiftPointerR();
			} else if command == BFEnum.LTHAN {
				wait(0.1)
				self.shiftPointerL();
			} else if command == BFEnum.PLUS {
				wait(0.1)
				cellptr = self.cellptr.to_const(0..self.cells.length);
				self.cells[cellptr].increment(1);
			} else if command == BFEnum.MINUS {
				wait(0.1)
				cellptr = self.cellptr.to_const(0..self.cells.length);
				self.cells[cellptr].decrement(1);
			} else {
				wait(0.1)
				cellptr = self.cellptr.to_const(0..self.cells.length);
				if command == BFEnum.LBRAC && self.cells[cellptr] == 0 {
					self.codeptr = MDFind(self.codeptr,bracemap)
				} else if command == BFEnum.RBRAC && self.cells[cellptr] != 0 {
					self.codeptr = MDFind(self.codeptr,bracemap);
				}
			}
			
			wait(0.3);
		})


		loop = {
            codeptr = self.codeptr.to_const(0..self.code.length);
			-> 9c.pulse(128,0,128, fade_out = 0.5);
			reset_command!
			wait(0.1)
			command += self.code[codeptr]
			wait(0.1)
            compile_command()
            wait(0.1)
            -> 8c.pulse(128,0,128, fade_out = 0.5);
			self.codeptr += 1;
			wait(0.1)
            loop!
        }
        loop!
		
	}

}
69i.add(0);
let mySystem = @BFSystem::new(4);

let mycode = stringToArr('[>+>>]');

mySystem.update(mycode);
mySystem.compile()