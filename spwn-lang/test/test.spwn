BFEnum = {
	PLUS: 0,
	MINUS: 1,
	GTHAN: 2,
	LTHAN: 3,
	RBRAC: 4,
	LBRAC: 5,
	DOT: 6
};

constants = {
	pointer: 5g,
	pointer_color: 5c,
	highlighted: [0,255,255],
}
to_wait = 0.1;

mdfind_err = counter(420i);
mdfind_notfound = counter(421i);
MDFind = (search: @counter, arr: @array) {
    found = counter(500i);
    mdfind_err = search
    for item in arr {
        if search == item[0] {
            found += 1
            return item[1];
            break
        } else {
        	mdfind_notfound = item[0];
        	wait(0.5);
        }
    }
    if found == 0 {
        //696i.add(99999);
        return search;
    } else {
        wait()
        found -= 1
    }
}

stringToArr = (code: @string) {
	let arr = [];
	for chi in 0..code.length {
		char = code[chi];
		if char == '+' {arr.push(BFEnum.PLUS)};
		if char == '-' {arr.push(BFEnum.MINUS)};
		if char == '>' {arr.push(BFEnum.GTHAN)};
		if char == '<' {arr.push(BFEnum.LTHAN)};
		if char == '[' {arr.push(BFEnum.LBRAC)};
		if char == ']' {arr.push(BFEnum.RBRAC)};
		if char == '.' {arr.push(BFEnum.DOT)};
	}
	return arr;
}

type @Cell;
type @BFSystem;

impl @Cell {
	new: (color: @color,item: @item, group: @group) {
		item.add(0);
		return {type: @Cell,item: counter(item), group: group, color: color}
	},
	increment: (self, by) {
		self.item += by;
		->self.color.pulse(0, 255, 0, 0, 0.1, 0.5);
	},
	decrement: (self, by) {
		self.item -= by;
		->self.color.pulse(255, 0, 0, 0, 0.1, 0.5);
	},
	movePointerTo: (self) {
		->constants.pointer.move_to(self.group, 0.1, true);
	}
}

impl @BFSystem {
	new: (num) {
		let slf = {type: @BFSystem};

		let slf.cells = [];
		let slf.cellptr = counter(696i);
		let slf.codeptr = counter(69i);
		let slf.codelen = counter(num);
		let slf.code = [];
		for cell in 1..num+1 {
        	slf.cells.push(@Cell::new(cell as @color, cell as @item, cell as @group));
    	}
    	return slf;
	},
	update: (self, updated: @array) {
		for i in updated {
			self.code.push(i);
		}
	},

	shiftPointerR: (self) {
        if self.cellptr == self.cells.length - 1 {
            wait()
            self.cellptr -= self.cells.length - 1
        } else {
            wait()
            self.cellptr+=1;
		}
		wait();

		index = self.cellptr.to_const(0..self.cells.length);
        wait();

    	-> self.cells[index].movePointerTo();
    },

    shiftPointerL: (self) {
        
        if self.cellptr == 0 {
            wait()
            self.cellptr += self.cells.length - 1
        } else {
            wait()
            self.cellptr-=1;
		}
		wait();

		index = self.cellptr.to_const(0..self.cells.length);
        wait();
        -> self.cells[index].movePointerTo();
	},
	
	getBracemap: (self) {
		let bracestack = [];
		let bracemap = [];

		let command = 0;
		for position in 0..self.code.length {
			command = self.code[position];

			if command == BFEnum.LBRAC {
				bracestack.push(position);
			} else if command == BFEnum.RBRAC {
				let start = bracestack.pop();

				$.print(start as @string + "," + position as @string);
				$.print(position as @string + "," + start as @string);
				bracemap.push([counter(start),counter(position)]);
				bracemap.push([counter(position),counter(start)]);
			}
		}
		return bracemap;
	},

	compile: (self) {
		let bracemap = self.getBracemap();
		$.print(self.code);
		//$.print(bracemap);
		command = counter(70i)
		reset_command = {
			command -= command.to_const(0..7)
		}

		compile_command = sync_function(() {
			
			
			if command == BFEnum.GTHAN {
				//wait(to_wait)
				self.shiftPointerR();
			} else if command == BFEnum.LTHAN {
				//wait(to_wait)
				self.shiftPointerL();
			} else if command == BFEnum.PLUS {
				//wait(to_wait)
				cellptr = self.cellptr.to_const(0..self.cells.length);
				self.cells[cellptr].increment(1);
			} else if command == BFEnum.MINUS {
				//wait(to_wait)
				cellptr = self.cellptr.to_const(0..self.cells.length);
				self.cells[cellptr].decrement(1);
			}	else {
                //wait(to_wait)
                search = sync_function((){
                    self.codeptr = MDFind(self.codeptr,bracemap)
                })
                cellptr = self.cellptr.to_const(0..self.cells.length);
                if command == BFEnum.LBRAC && self.cells[cellptr].item == 0 {
                    search()
                } else if command == BFEnum.RBRAC && self.cells[cellptr].item != 0 {
                    search()
                }
            }
			
			wait(0.3);
		});


		loop = {
            codeptr = self.codeptr.to_const(0..self.code.length);
			reset_command!
			wait(to_wait)
			command += self.code[codeptr]
			wait(to_wait)
            compile_command()
            wait(to_wait)
            //-> 7c.pulse(128,0,128, fade_out = 0.5);
			self.codeptr += 1;
			wait(to_wait)
            loop!
        }
        loop!
		
	}

}
69i.add(0);
696i.add(0);
let mySystem = @BFSystem::new(3);

let mycode = stringToArr('+++++[->++[>+<-]<]>>');

mySystem.update(mycode);
mySystem.compile()