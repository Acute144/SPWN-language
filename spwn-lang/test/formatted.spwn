let constants = import "constants.spwn"
extract constants.obj_props
extract constants.comparisons
extract constants.easing_types
wait = "#[desc(\"Adds a delay before the next triggers\",), ] (#[desc(\"Delay time in seconds\",), ] time: @number,{\t$.add(\t{\nOBJ_ID:1268,\nSPAWN_DURATION:time,\nTARGET:{\n\t\treturn\n\t}\t\n})\n\n}"
call_with_delay = "#[desc(\"Call a function after a delay\",), ] (#[desc(\"Delay time in seconds\",), ] time: @number,#[desc(\"Function to call after the delay\",), ] function: @function,{\t$.add(\t{\nOBJ_ID:1268,\nSPAWN_DURATION:time,\nTARGET:function\t\n})\n\n}"
impl @group {
	move: "#[desc(\"Implementation of the move trigger\",), ] (self,#[desc(\"Units to move on the X axis\",), ] x: @number,#[desc(\"Units to move on the Y axis\",), ] y: @number,#[desc(\"Duration of movement\",), ] duration: @number = 0,easing: @number = NONE,easing_rate: @number = 2,{\t$.add(\t{\nOBJ_ID:901,\nTARGET:self,\nMOVE_X:x * 3,\nMOVE_Y:y * 3,\nDURATION:duration,\nEASING:easing,\nEASING_RATE:easing_rate\t\n})\n\twait(duration)\n\n}",
	stop: "#[desc(\"Implementation of the stop trigger\",), ] (self,{\t$.add(\t{\nOBJ_ID:1616,\nTARGET:self\t\n})\n\n}",
	alpha: "#[desc(\"Implementation of the alpha trigger\",), ] (self,opacity: @number = 1,duration: @number = 0,{\t$.add(\t{\nOBJ_ID:1007,\nTARGET:self,\nOPACITY:opacity,\nDURATION:duration\t\n})\n\twait(duration)\n\n}",
	toggle_on: "#[desc(\"Toggles the group on\",), ] (self,{\t$.add(\t{\nOBJ_ID:1049,\nTARGET:self,\nACTIVATE_GROUP:true\t\n})\n\n}",
	toggle_off: "#[desc(\"Toggles the group off\",), ] (self,{\t$.add(\t{\nOBJ_ID:1049,\nTARGET:self,\nACTIVATE_GROUP:false\t\n})\n\n}",
	rotate: "#[desc(\"Implementation of the rotate trigger\",), ] (self,#[desc(\"Group of object to rotate around\",), ] center: @group,#[desc(\"Rotation in degrees\",), ] degrees: @number,#[desc(\"Duration of rotation\",), ] duration: @number = 0,#[desc(\"Easing type\",), ] easing: @number = 0,#[desc(\"Easing rate\",), ] easing_rate: @number = 2,#[desc(\"Only rotate positions of the objects, not the textures\",), ] lock_object_rotation: @bool = false,{\t$.add(\t{\nOBJ_ID:1346,\nTARGET:self,\nCENTER:center,\nROTATE_DEGREES:degrees,\nDURATION:duration,\nEASING:easing,\nEASING_RATE:easing_rate,\nLOCK_OBJECT_ROTATION:lock_object_rotation\t\n})\n\twait(duration)\n\n}",
	follow: "#[desc(\"Implementation of the follow trigger\",), ] (self,#[desc(\"Group of object to follow\",), ] other: @group,#[desc(\"Multiplier for the movement on the X-axis\",), ] x_mod: @number = 1,#[desc(\"Multiplier for the movement on the Y-axis\",), ] y_mod: @number = 1,#[desc(\"Duration of following\",), ] duration: @number = 999,{\t$.add(\t{\nOBJ_ID:1347,\nX_MOD:x_mod,\nY_MOD:y_mod,\nDURATION:duration,\nTARGET:self,\nFOLLOW:other\t\n})\n\n}",
	follow_player_y: "#[desc(\"Implementation of the follow player Y trigger\",), ] (self,#[desc(\"Interpolation factor (?)\",), ] speed: @number = 1,#[desc(\"Delay of movement\",), ] delay: @number = 0,#[desc(\"Offset on the Y-axis\",), ] offset: @number = 0,#[desc(\"Maximum speed\",), ] max_speed: @number = 0,#[desc(\"Duration of following\",), ] duration: @number = 999,{\t$.add(\t{\nOBJ_ID:1814,\nSPEED:speed,\nDELAY:delay,\nY_OFFSET:offset,\nMAX_SPEED:max_speed,\nDURATION:duration\t\n})\n\n}",
	move_to: "#[desc(\"Implementation of the \'Move target\' feature of the move trigger\",), ] (self,#[desc(\"Group of the object to move to\",), ] target: @group,#[desc(\"Duration of movement\",), ] duration: @number = 0,#[desc(\"Will move to the object only on the X-axis\",), ] x_only: @bool = false,#[desc(\"Will move to the object only on the y-axis\",), ] y_only: @bool = false,#[desc(\"Easing type\",), ] easing: @number = NONE,#[desc(\"Easing rate\",), ] easing_rate: @number = 2,{\t$.add(\t{\nOBJ_ID:901,\nTARGET:self,\nUSE_TARGET:true,\nTARGET_POS_AXES:\"({\\t\\tif x_only && y_only {\\n\\t\\treturn 0\\n\\n}else {\\n\\t\\tif x_only {\\n\\t\\treturn 1\\n\\n}else {\\n\\t\\tif y_only {\\n\\t\\treturn 2\\n\\n}else {\\n\\t\\treturn 0\\n\\n}\\n\\n}\\n\\n}\\n\\n\\t}\"(),\nTARGET_POS:target,\nDURATION:duration,\nEASING:easing,\nEASING_RATE:easing_rate\t\n})\n\twait(duration)\n\n}",
	pulse: "#[desc(\"Implementation of the pulse trigger for groups\",), ] (self,#[desc(\"Red value of pulse color (or hue if HSV is enabled)\",), ] r: @number,#[desc(\"Green value of pulse color (or saturation if HSV is enabled)\",), ] g: @number,#[desc(\"Blue value of pulse color (or brightness/value if HSV is enabled)\",), ] b: @number,#[desc(\"Fade-in duration\",), ] fade_in: @number = 0,#[desc(\"Duration to hold the color\",), ] hold: @number = 0,#[desc(\"Fade-out duration\",), ] fade_out: @number = 0,#[desc(\"Weather to prioritize this pulse over simultaneous pulses\",), ] exclusive: @bool = false,#[desc(\"Toggle HSV mode\",), ] hsv: @bool = false,{\t$.add(\t{\nOBJ_ID:1006,\nTRIGGER_RED:r,\nTRIGGER_GREEN:g,\nTRIGGER_BLUE:b,\nEXCLUSIVE:exclusive,\nFADE_IN:fade_in,\nHOLD:hold,\nFADE_OUT:fade_out,\nTARGET_COLOR:self,\nPULSE_MODE:hsv,\nTARGET_TYPE:1\t\n})\n\twait(fade_in + hold + (fade_out))\n\n}
}
impl @color {
	set: "#[desc(\"Implementation of the color trigger\",), ] (self,#[desc(\"Red value of the target color\",), ] r: @number,#[desc(\"Green value of the target color\",), ] g: @number,#[desc(\"Blue value of the target color\",), ] b: @number,#[desc(\"Duration of color change\",), ] duration: @number = 0,#[desc(\"Opacity of target color\",), ] opacity: @number = 1,#[desc(\"Toggle blending on target color\",), ] blending: @bool = false,{\t$.add(\t{\nOBJ_ID:899,\nDURATION:duration,\nTRIGGER_RED:r,\nTRIGGER_GREEN:g,\nTRIGGER_BLUE:b,\nOPACITY:opacity,\nBLENDING:blending,\nTARGET_COLOR:self\t\n})\n\twait(duration)\n\n}",
	pulse: "#[desc(\"Implementation of the pulse trigger for colors\",), ] (self,#[desc(\"Red value of pulse color (or hue if HSV is enabled)\",), ] r: @number,#[desc(\"Green value of pulse color (or saturation if HSV is enabled)\",), ] g: @number,#[desc(\"Blue value of pulse color (or brightness/value if HSV is enabled)\",), ] b: @number,#[desc(\"Fade-in duration\",), ] fade_in: @number = 0,#[desc(\"Duration to hold the color\",), ] hold: @number = 0,#[desc(\"Fade-out duration\",), ] fade_out: @number = 0,#[desc(\"Weather to prioritize this pulse over simultaneous pulses\",), ] exclusive: @bool = false,#[desc(\"Toggle HSV mode\",), ] hsv: @bool = false,{\t$.add(\t{\nOBJ_ID:1006,\nTRIGGER_RED:r,\nTRIGGER_GREEN:g,\nTRIGGER_BLUE:b,\nEXCLUSIVE:exclusive,\nFADE_IN:fade_in,\nHOLD:hold,\nFADE_OUT:fade_out,\nTARGET:self,\nPULSE_MODE:hsv\t\n})\n\twait(fade_in + hold + (fade_out))\n\n}
}
impl @item {
	add: "#[desc(\"Implementation of the pickup trigger\",), ] (self,#[desc(\"Amount to add\",), ] amount: @number,{\t$.add(\t{\nOBJ_ID:1817,\nCOUNT:amount,\nITEM:self\t\n})\n\n}",
	if_is: "#[desc(\"Implementation of the instant count trigger\",), ] (self,#[desc(\"Comparison mode\",), ] comparison: @number,#[desc(\"Number to compare with\",), ] other: @number,#[desc(\"Target function if comparison is \'true\'\",), ] function: @function,{\t$.add(\t{\nOBJ_ID:1811,\nTARGET:function,\nCOUNT:other,\nACTIVATE_GROUP:1,\nCOMPARISON:comparison,\nITEM:self\t\n})\n\n}",
	count: "#[desc(\"Implementation of the count trigger (returns an event)\",), ] (self,#[desc(\"Number to check against\",), ] number: @number = 0,{\treturn \"(function,{\\t\\t$.add(\\t\\t{\\nOBJ_ID:1611,\\nTARGET:function,\\nCOUNT:number,\\nACTIVATE_GROUP:1,\\nITEM:self,\\nCOUNT_MULTI_ACTIVATE:true\\t\\t\\n})\\n\\n\\t}\"\n\n}
}
type counter
counter = "#[desc(\"Creates a new counter\",), ] (#[desc(\"Source (can be a number, item ID or boolean)\",), ] source = 0,{\tif source.type == @number {\n\tid = ?i\n\tid.add(source)\n\treturn \t{\n\t\ttype: @counter,\n\t\titem: id\t\n}\n\n}else {\n\tif source.type == @item {\n\treturn \t{\n\t\ttype: @counter,\n\t\titem: source\t\n}\n\n}else {\n\tif source.type == @bool {\n\tid = ?i\n\tif source {\n\tid.add(1)\n\n}\n\treturn \t{\n\t\ttype: @counter,\n\t\titem: id\t\n}\n\n}else {\n\terror \"Can not make counter from this type\"\n\n}\n\n}\n\n}\n\n}"
supress_signal = "#[desc(\"Stops signal from coming past for some time\",), ] (#[desc(\"Time to supress signal\",), ] delay: @number,{\tchecker = counter(0)\n\t->\"({\\t\\twait(delay * 2)\\n\\t\\tchecker.item.if_is(EQUAL_TO,1,{\\n\\t\\t\\tchecker.item.add(-1)\\n\\t\\t})\\n\\n\\t}\"()\n\tchecker.item.if_is(EQUAL_TO,0,{\n\t\tchecker.item.add(1)\n\t\treturn\n\t})\n\n}"
DEFAULT_SPEED = 3
impl @counter {
	add_to: "#[desc(\"Adds the counter\'s value to all item IDs in a list, and resets the counter to 0 in the process\",), ] (self,#[desc(\"Item IDs to add to\",), ] items: @array,#[desc(\"Speed of operation (higher number increases group usage)\",), ] speed: @number = DEFAULT_SPEED,#[desc(\"Multiplyer for the value added\",), ] factor: @number = 1,{\tadd = {\n\t\tmini_add = \"(num,{\\t\\t\\tself.item.if_is(LARGER_THAN,num - 1,{\\n\\t\\t\\t\\tself.item.add(-num)\\n\\t\\t\\t\\tfor item in items {\\n\\t\\t\\t\\titem.add(num * factor)\\n\\n}\\n\\t\\t\\t\\tcall_with_delay(0.05,add)\\n\\t\\t\\t})\\n\\n\\t\\t}\"\n\t\tfor i in 0 .. speed {\n\t\tmini_add(3 ^ i)\n\n}\n\t\tself.item.if_is(EQUAL_TO,0,{\n\t\t\twait(0.05)\n\t\t\tsupress_signal(0.06)\n\t\t\treturn\n\t\t})\n\t}\n\tadd!\n\n}",
	subtract_from: "#[desc(\"Subtracts the counter\'s value from all item IDs in a list, and resets the counter to 0 in the process\",), ] (self,#[desc(\"Item IDs to add to\",), ] items: @array,#[desc(\"Speed of operation (higher number increases group usage)\",), ] speed: @number = DEFAULT_SPEED,{\tsub = {\n\t\tself.item.if_is(LARGER_THAN,0,{\n\t\t\tmini_sub = \"(num,{\\t\\t\\t\\tself.item.if_is(LARGER_THAN,num - 1,{\\n\\t\\t\\t\\t\\tself.item.add(-num)\\n\\t\\t\\t\\t\\tfor item in items {\\n\\t\\t\\t\\t\\titem.add(-num)\\n\\n}\\n\\t\\t\\t\\t\\tcall_with_delay(0.05,sub)\\n\\t\\t\\t\\t})\\n\\n\\t\\t\\t}\"\n\t\t\tfor i in 0 .. speed {\n\t\t\tmini_sub(2 ^ i)\n\n}\n\t\t})\n\t\tself.item.if_is(EQUAL_TO,0,{\n\t\t\twait(0.05)\n\t\t\tsupress_signal(0.06)\n\t\t\treturn\n\t\t})\n\t}\n\tsub!\n\n}",
	multiply: "#[desc(\"Multiplies the value of the counter by some factor\",), ] (self,#[desc(\"Factor to multiply by, either another counter (very expensive) or a normal number\",), ] factor,#[desc(\"Speed of operation (higher number increases group usage)\",), ] speed: @number = DEFAULT_SPEED,{\tif factor.type == @number {\n\ttemp = counter(0)\n\tself.add_to([temp.item],speed,factor)\n\ttemp.add_to([self.item],speed)\n\n}else {\n\tif factor.type == @counter {\n\ttemp = counter(0)\n\tmini_mult = \"(num,{\\t\\tmult = {\\n\\t\\t\\tself.item.if_is(LARGER_THAN,num - 1,{\\n\\t\\t\\t\\tself.item.add(-num)\\n\\t\\t\\t\\tfactor.copy_to(temp.item,speed,num)\\n\\t\\t\\t\\tcall_with_delay(0.1,mult)\\n\\t\\t\\t})\\n\\t\\t\\tself.item.if_is(SMALLER_THAN,num,{\\n\\t\\t\\t\\twait(0.1)\\n\\t\\t\\t\\tsupress_signal(0.11)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t})\\n\\t\\t}\\n\\t\\tmult!\\n\\n\\t}\"\n\tfor i in speed .. 0 {\n\tmini_mult(2 ^ i)\n\n}\n\t->factor.reset(speed)\n\ttemp.add_to([self.item],speed * 2)\n\n}\n\n}\n\n}",
	divide: "#[desc(\"Devides the value of the counter by some divisor\",), ] (self,#[desc(\"Divisor to divide by, either another counter (very expensive) or a normal number\",), ] divisor,#[desc(\"Speed of operation (higher number increases group usage)\",), ] speed: @number = DEFAULT_SPEED,#[desc(\"Item ID to add the remainder of the division to\",), ] rest_item: @item = ?i,{\tif divisor.type == @number {\n\tresult = counter(0)\n\trest = counter(rest_item)\n\tdiv = {\n\t\tmini_div = \"(num,{\\t\\t\\tself.item.if_is(LARGER_THAN,(divisor * num) - 1,{\\n\\t\\t\\t\\tself.item.add(-(divisor * num))\\n\\t\\t\\t\\tresult.item.add(num)\\n\\t\\t\\t\\tcall_with_delay(0.05,div)\\n\\t\\t\\t})\\n\\n\\t\\t}\"\n\t\tfor i in 0 .. speed {\n\t\tmini_div((i * 4) + (1))\n\n}\n\t\tself.item.if_is(SMALLER_THAN,divisor,{\n\t\t\twait(0.05)\n\t\t\tself.add_to([rest.item],speed)\n\t\t\tresult.add_to([self.item],speed)\n\t\t\tsupress_signal(0.06)\n\t\t\treturn rest\n\t\t})\n\t}\n\tdiv!\n\n}else {\n\tif divisor.type == @counter {\n\tresult = counter(0)\n\tmini_div = \"(num,{\\t\\tdiv = {\\n\\t\\t\\tself.item.if_is(LARGER_THAN,0,{\\n\\t\\t\\t\\t\\\"({\\\\t\\\\t\\\\t\\\\t\\\\ttemp_storage = ?i\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcas = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmini_cas = \\\\\\\"(num2,{\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\tdivisor.item.if_is(LARGER_THAN,num2 - 1,{\\\\\\\\n\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\tdivisor.item.add(-num2)\\\\\\\\n\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\ttemp_storage.add(num2)\\\\\\\\n\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\tself.item.add(-(num2 * num))\\\\\\\\n\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\tcall_with_delay(0.05,cas)\\\\\\\\n\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t})\\\\\\\\n\\\\\\\\n\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t\\\\\\\\t}\\\\\\\"\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor i in 0 .. speed {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmini_cas(3 ^ i)\\\\n\\\\n}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdivisor.item.if_is(EQUAL_TO,0,{\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twait(0.1)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsupress_signal(0.11)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcounter(temp_storage).add_to([divisor.item],speed * 2)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t})\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcas!\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t}\\\"()\\n\\t\\t\\t\\tresult.item.add(num)\\n\\t\\t\\t\\tcall_with_delay(0.1,div)\\n\\t\\t\\t})\\n\\t\\t\\tself.item.if_is(SMALLER_THAN,1,{\\n\\t\\t\\t\\tret = {\\n\\t\\t\\t\\t\\tsupress_signal(0.11)\\n\\t\\t\\t\\t\\twait(0.1)\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsupress_signal(0.06)\\n\\t\\t\\t\\tself.item.if_is(SMALLER_THAN,0,{\\n\\t\\t\\t\\t\\tresult.item.add(-num)\\n\\t\\t\\t\\t\\twait(0.1)\\n\\t\\t\\t\\t\\tdivisor.copy_to(self.item,speed * 2,factor = num)\\n\\t\\t\\t\\t\\tret!\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\tself.item.if_is(EQUAL_TO,0,ret)\\n\\t\\t\\t})\\n\\t\\t}\\n\\t\\tdiv!\\n\\n\\t}\"\n\tfor i in speed .. 0 {\n\tmini_div(8 ^ i)\n\twait(0.1)\n\n}\n\t->divisor.reset(speed)\n\tself.add_to([rest_item],speed * 2)\n\tresult.add_to([self.item],speed * 2)\n\twait(0.2)\n\treturn counter(rest_item)\n\n}\n\n}\n\n}",
	reset: "#[desc(\"Resets counter to 0\",), ] (self,#[desc(\"Speed of operation (higher number increases group usage)\",), ] speed: @number = DEFAULT_SPEED,{\tadd = {\n\t\tself.item.if_is(LARGER_THAN,0,{\n\t\t\tmini_add = \"(num,{\\t\\t\\t\\tself.item.if_is(LARGER_THAN,num - 1,{\\n\\t\\t\\t\\t\\tself.item.add(-num)\\n\\t\\t\\t\\t\\tcall_with_delay(0.05,add)\\n\\t\\t\\t\\t})\\n\\n\\t\\t\\t}\"\n\t\t\tfor i in 0 .. speed {\n\t\t\tmini_add(3 ^ i)\n\n}\n\t\t})\n\t\tself.item.if_is(EQUAL_TO,0,{\n\t\t\twait(0.05)\n\t\t\tsupress_signal(0.05)\n\t\t\treturn\n\t\t})\n\t}\n\tadd!\n\n}",
	copy_to: "#[desc(\"Copies the value of the counter to another item ID, without consuming the original\",), ] (self,#[desc(\"Item ID to copy to\",), ] item: @item,#[desc(\"Speed of operation (higher number increases group usage)\",), ] speed: @number = DEFAULT_SPEED,#[desc(\"Factor of to multiply the copy by\",), ] factor: @number = 1,{\ttemp_storage = ?i\n\tadd = {\n\t\tself.item.if_is(LARGER_THAN,0,{\n\t\t\tmini_add = \"(num,{\\t\\t\\t\\tself.item.if_is(LARGER_THAN,num - 1,{\\n\\t\\t\\t\\t\\tself.item.add(-num)\\n\\t\\t\\t\\t\\titem.add(num * factor)\\n\\t\\t\\t\\t\\ttemp_storage.add(num)\\n\\t\\t\\t\\t\\tcall_with_delay(0.05,add)\\n\\t\\t\\t\\t})\\n\\n\\t\\t\\t}\"\n\t\t\tfor i in 0 .. speed {\n\t\t\tmini_add(2 ^ i)\n\n}\n\t\t})\n\t\tself.item.if_is(EQUAL_TO,0,{\n\t\t\twait(0.05)\n\t\t\tsupress_signal(0.06)\n\t\t\tcounter(temp_storage).add_to([self.item],speed)\n\t\t\treturn\n\t\t})\n\t}\n\tadd!\n\n}",
	clone: "#[desc(\"Copies the counter and returns the copy\",), ] (self,#[desc(\"Speed of operation (higher number increases group usage)\",), ] speed: @number = DEFAULT_SPEED,{\tnew_counter = ?i\n\tself.copy_to(new_counter,speed)\n\treturn counter(new_counter)\n\n}",
	_plus_: "(self,other,{\tif other.type == @number {\n\tnew_counter = self.clone()\n\tnew_counter.item.add(other)\n\treturn new_counter\n\n}else {\n\tif other.type == @counter {\n\tnew_counter = self.clone()\n\tother.clone().add_to([new_counter.item])\n\treturn new_counter\n\n}\n\n}\n\n}",
	_minus_: "(self,other,{\tif other.type == @number {\n\tnew_counter = self.clone()\n\tnew_counter.item.add(-other)\n\treturn new_counter\n\n}\n\n}",
	_more_than_: "(self,other,{\tif other.type == @number {\n\tself.item.if_is(LARGER_THAN,other,{\n\t\treturn true\n\t})\n\tself.item.if_is(SMALLER_THAN,other + 1,{\n\t\treturn false\n\t})\n\n}\n\n}",
	_less_than_: "(self,other,{\tif other.type == @number {\n\tself.item.if_is(SMALLER_THAN,other,{\n\t\treturn true\n\t})\n\tself.item.if_is(LARGER_THAN,other - 1,{\n\t\treturn false\n\t})\n\n}\n\n}",
	_more_or_equal_: "(self,other,{\tif other.type == @number {\n\tself.item.if_is(LARGER_THAN,other - 1,{\n\t\treturn true\n\t})\n\tself.item.if_is(SMALLER_THAN,other,{\n\t\treturn false\n\t})\n\n}\n\n}",
	_less_or_equal_: "(self,other,{\tif other.type == @number {\n\tself.item.if_is(SMALLER_THAN,other + 1,{\n\t\treturn true\n\t})\n\tself.item.if_is(LARGER_THAN,other,{\n\t\treturn false\n\t})\n\n}\n\n}",
	_equal_: "(self,other,{\tif other.type == @number {\n\tself.item.if_is(EQUAL_TO,other,{\n\t\treturn true\n\t})\n\tret_false = {\n\t\treturn false\n\t}\n\tself.item.if_is(LARGER_THAN,other,ret_false)\n\tself.item.if_is(SMALLER_THAN,other,ret_false)\n\n}\n\n}",
	_not_equal_: "(self,other,{\treturn !(self == other)\n\n}",
	add: "#[desc(\"Implementation of the pickup trigger\",), ] (self,#[desc(\"Amount to add\",), ] num: @number,{\tself.item.add(num)\n\n}",
	_add_: "(self,num,{\tself.item.add(num)\n\n}",
	_subtract_: "(self,num,{\tself.item.add(-num)\n\n}",
	_multiply_: "(self,num,{\tself.multiply(num)\n\n}",
	_divide_: "(self,num,{\tself.divide(num)\n\n}",
	_assign_: "(self,num,{\tself.reset()\n\tself.item.add(num)\n\n}",
	to_const: "#[desc(\"Converts the counter into a normal number (very context-splitting, be careful)\",), ] (self,#[desc(\"Array of possible output values\",), ] range: @array,{\tfor val in range {\n\t->self.item.if_is(EQUAL_TO,val,{\n\t\treturn val\n\t})\n\n}\n\n}",
	_as_: "(self,_type: @type_indicator,{\tif _type == @bool {\n\treturn self.to_const([0,1]) == 1\n\n}else {\n\terror \"Cannot convert to this type (counter can convert to a number using the counter.to_const macro)\"\n\n}\n\n}
}
general_functions = {
	shake: "#[desc(\"Implementation of the shake trigger\",), ] (#[desc(\"Strength value\",), ] strength: @number = 1,#[desc(\"Interval value\",), ] interval: @number = 0,#[desc(\"Duration of shake\",), ] duration: @number = 0.5,{\t\t$.add(\t\t{\nOBJ_ID:1520,\nSTRENGTH:strength,\nINTERVAL:interval,\nDURATION:duration\t\t\n})\n\t\twait(duration)\n\n\t}",
	disable_trail: "#[desc(\"Disables the player\'s trail\",), ] ({\t\t$.add(\t\t{\nOBJ_ID:33\t\t\n})\n\n\t}",
	enable_trail: "#[desc(\"Enables the player\'s trail\",), ] ({\t\t$.add(\t\t{\nOBJ_ID:32\t\t\n})\n\n\t}",
	show_player: "#[desc(\"Shows the player\",), ] ({\t\t$.add(\t\t{\nOBJ_ID:1613\t\t\n})\n\n\t}",
	hide_player: "#[desc(\"Hides the player\",), ] ({\t\t$.add(\t\t{\nOBJ_ID:1612\t\t\n})\n\n\t}",
	toggle_bg_effect: "#[desc(\"Implementation of the bg effect on/off triggers\",), ] (#[desc(\"Weather to toggle bg effect on or off\",), ] on: @bool = false,{\t\tif on {\n\t\t$.add(\t\t{\nOBJ_ID:1818\t\t\n})\n\n}else {\n\t\t$.add(\t\t{\nOBJ_ID:1819\t\t\n})\n\n}\n\n\t}",
	loop: "#[desc(\"Implementation of a spawn loop\",), ] (#[desc(\"Start value for the iterator\",), ] start_val: @number,#[desc(\"End value for the iterator\",), ] end_val: @number,#[desc(\"Macro of the code that gets looped, should take the iterator (a counter) as the first argument\",), ] code: @macro,#[desc(\"Delay between loops (less than 0.05 may be unstable)\",), ] delay: @number = 0.05,#[desc(\"Weather to reset the iterator after looping (only disable if the loop is only triggered once)\",), ] reset: @bool = true,#[desc(\"Operation speed of the reset of the iterator, if enabled\",), ] reset_speed: @number = 1,{\t\ti = counter(start_val)\n\t\tfunc = {\n\t\t\tcode(i)\n\t\t\ti.add(1)\n\t\t\ti.item.if_is(SMALLER_THAN,end_val,{\n\t\t\t\tcall_with_delay(delay,func)\n\t\t\t})\n\t\t\ti.item.if_is(LARGER_THAN,end_val - 1,{\n\t\t\t\tif reset {\n\t\t\t\ti.reset(reset_speed)\n\n}\n\t\t\t\treturn\n\t\t\t})\n\t\t}\n\t\tfunc!\n\n\t}"
}
on = "#[desc(\"Triggers a function every time an event fires\",), ] (#[desc(\"Event to trigger on\",), ] event: @macro,#[desc(\"Function to trigger\",), ] function: @function,{\tevent(function)\n\n}"
events = {
	touch: "#[desc(\"Implementation of the touch trigger (returns an event)\",), ] (#[desc(\"Dual mode (only check for touch on the dual side)\",), ] dual_side = false,{\t\treturn \"(function,{\\t\\t\\t$.add(\\t\\t\\t{\\nOBJ_ID:1595,\\nHOLD_MODE:true,\\nTOGGLE_MODE:1,\\nTARGET:function,\\nDUAL_MODE:dual_side\\t\\t\\t\\n})\\n\\n\\t\\t}\"\n\n\t}",
	touch_end: "#[desc(\"Returns an event for when a touch ends\",), ] (#[desc(\"Dual mode (only check for touch on the dual side)\",), ] dual_side = false,{\t\treturn \"(function,{\\t\\t\\t$.add(\\t\\t\\t{\\nOBJ_ID:1595,\\nHOLD_MODE:true,\\nTOGGLE_MODE:2,\\nTARGET:function,\\nDUAL_MODE:dual_side\\t\\t\\t\\n})\\n\\n\\t\\t}\"\n\n\t}",
	collision: "#[desc(\"Implementation of the collision trigger (returns an event)\",), ] (#[desc(\"Block A ID\",), ] a,#[desc(\"Block B ID\",), ] b,{\t\treturn \"(function,{\\t\\t\\t$.add(\\t\\t\\t{\\nOBJ_ID:1815,\\nBLOCK_A:a,\\nBLOCK_B:b,\\nACTIVATE_GROUP:true,\\nTARGET:function\\t\\t\\t\\n})\\n\\n\\t\\t}\"\n\n\t}",
	collision_exit: "#[desc(\"Returns an event for when a collision exits\",), ] (#[desc(\"Block A ID\",), ] a,#[desc(\"Block B ID\",), ] b,{\t\treturn \"(function,{\\t\\t\\t$.add(\\t\\t\\t{\\nOBJ_ID:1815,\\nBLOCK_A:a,\\nBLOCK_B:b,\\nACTIVATE_GROUP:true,\\nACTIVATE_ON_EXIT:true,\\nTARGET:function\\t\\t\\t\\n})\\n\\n\\t\\t}\"\n\n\t}",
	death: "#[desc(\"Returns an event for when the player dies\",), ] ({\t\treturn \"(function,{\\t\\t\\t$.add(\\t\\t\\t{\\nOBJ_ID:1812,\\nACTIVATE_GROUP:true,\\nTARGET:function\\t\\t\\t\\n})\\n\\n\\t\\t}\"\n\n\t}"
}
impl @block {
	create_tracker_item: "#[desc(\"Returns an item ID that is 1 when the blocks are colliding and 0 when they are not\",), ] (self,#[desc(\"Block ID to check against\",), ] other,{\titem = ?i\n\ton(events.collision(self,other),{\n\t\titem.add(1)\n\t})\n\ton(events.collision_exit(self,other),{\n\t\titem.add(-1)\n\t})\n\treturn item\n\n}
}
exports = {
	obj_props: constants.obj_props,
	..constants.easing_types,
	..constants.comparisons,
	..constants.colors,
	..general_functions,
	..events,
	wait: wait,
	supress_signal: supress_signal,
	counter: counter,
	call_with_delay: call_with_delay,
	on: on
}
