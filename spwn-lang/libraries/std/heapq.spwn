#[no_std, cache_output]
// import "array.spwn"

type @heapq

impl @heapq {
    new: (arr: @array = [0], comp: @macro = (a, b) => a <= b) {
        if !arr.all(el => el != null) {
            throw "HeapError: Elements of heap should not be null"
        }

        let pobj = {
            type: @heapq,
            arr: arr,
            comp: comp,
            allocator: allocator,
            size: arr.length
        };

        pobj.heapify()

        return pobj
    },

    heapify: (self, root: @number = 0) {
        l = root * 2 + 1
        r = root * 2 + 2

        if l < self.size {
            self.heapify(l)

            if !self.comp(self.arr[root], self.arr[l]) {
                self.arr[root] <=> self.arr[l]
            }
        }
        
        if r < self.size {
            self.heapify(r)

            if !self.comp(self.arr[root], self.arr[r]) {
                self.arr[root] <=> self.arr[r]
            }
        }
    },

    insert: (self, val) {
        // swim up approach
        self.arr.push(val)
        
        
    }
}
